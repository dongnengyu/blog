{"meta":{"title":"做只猫","subtitle":"董能宇","description":null,"author":"董能宇","url":"http://yoursite.com/blog"},"pages":[{"title":"关于","date":"2018-05-14T17:00:14.291Z","updated":"2018-05-11T06:28:47.105Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/blog/about/index.html","excerpt":"","text":"姓名：董能宇联系方式：dongnengyu@gmail.comGitHub：dongnengyu"},{"title":"categories","date":"2018-05-10T13:37:57.000Z","updated":"2018-05-10T13:38:28.452Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/blog/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2018-05-14T17:00:14.331Z","updated":"2018-05-11T05:24:47.109Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/blog/links/index.html","excerpt":"","text":"欢迎技术类博客交换友链交换友链规则 申请前请先加上本站链接 http://dongnengyu.com 并发送电子邮件至(dongnengyu@gmail.com)，若符合要求我则为您的网站加上链接。 本人有权删除 长期不更新或者不能正常访问的网站链接，删除前会提前邮件告知对应网站管理员。 被删除链接的网站可在恢复访问后发送邮件联系恢复友链。 My Friends kindemh zhl的博客 网站架构"},{"title":"tags","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T13:36:54.075Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pyqt5笔记介绍","slug":"pyqt5学习笔记/pyqt5--介绍","date":"2018-06-09T11:36:23.396Z","updated":"2018-06-09T12:38:07.682Z","comments":true,"path":"2018/06/09/pyqt5学习笔记/pyqt5--介绍/","link":"","permalink":"http://yoursite.com/blog/2018/06/09/pyqt5学习笔记/pyqt5--介绍/","excerpt":"","text":"一、版权及免责声明版权声明：博主董能宇对本系列笔记内容拥有所有权，未经本人同意，禁止转载和用于其他商业用途。免责声明：该笔记源自本人业余学习pyqt5的经验，不对笔记中的任何东西负责。 二、笔记简介我觉得学习语言最好的方式就是项目驱动，所以本笔记主要是以项目需求来记录的。 三、目录 pyqt5--Hello world pyqt5--qml初级入门","categories":[{"name":"pyqt5笔记","slug":"pyqt5笔记","permalink":"http://yoursite.com/blog/categories/pyqt5笔记/"}],"tags":[{"name":"pyqt5","slug":"pyqt5","permalink":"http://yoursite.com/blog/tags/pyqt5/"}]},{"title":"pyqt5--qml初级入门","slug":"pyqt5学习笔记/pyqt5--qml初级入门","date":"2018-06-09T11:36:10.469Z","updated":"2018-06-09T12:43:09.198Z","comments":true,"path":"2018/06/09/pyqt5学习笔记/pyqt5--qml初级入门/","link":"","permalink":"http://yoursite.com/blog/2018/06/09/pyqt5学习笔记/pyqt5--qml初级入门/","excerpt":"","text":"项目需求 用pyqt5制作一个基于qml的基础gui程序，形如： 步骤： 建立pyqt5项目 建立main.py文件 建立main.qml文件 在两个文件之间建立联系","categories":[{"name":"pyqt5笔记","slug":"pyqt5笔记","permalink":"http://yoursite.com/blog/categories/pyqt5笔记/"}],"tags":[{"name":"pyqt5","slug":"pyqt5","permalink":"http://yoursite.com/blog/tags/pyqt5/"}]},{"title":"pyqt5--Hello world","slug":"pyqt5学习笔记/pyqt5--HelloWorld","date":"2018-06-09T11:23:13.190Z","updated":"2018-06-09T12:07:56.507Z","comments":true,"path":"2018/06/09/pyqt5学习笔记/pyqt5--HelloWorld/","link":"","permalink":"http://yoursite.com/blog/2018/06/09/pyqt5学习笔记/pyqt5--HelloWorld/","excerpt":"","text":"简单Hello world网上很多，懒得做了。如果真的有人看我的笔记的话，建议你自己去找官方例子","categories":[{"name":"pyqt5笔记","slug":"pyqt5笔记","permalink":"http://yoursite.com/blog/categories/pyqt5笔记/"}],"tags":[{"name":"pyqt5","slug":"pyqt5","permalink":"http://yoursite.com/blog/tags/pyqt5/"}]},{"title":"","slug":"2018-06-05","date":"2018-06-05T12:43:54.030Z","updated":"2018-06-09T12:25:01.948Z","comments":true,"path":"2018/06/05/2018-06-05/","link":"","permalink":"http://yoursite.com/blog/2018/06/05/2018-06-05/","excerpt":"","text":"title: 测试QT_DIR=/usr/local/Cellar/qt/5.11.0 qtdeploy test desktop /Users/xiaomu/go/src/StudentSystem 静态代码","categories":[],"tags":[]},{"title":"Mac环境下，安装webbench进行接口压力测试","slug":"java/Mac环境下，安装webbench进行接口压力测试","date":"2018-05-31T16:00:00.000Z","updated":"2018-06-09T11:27:13.388Z","comments":true,"path":"2018/06/01/java/Mac环境下，安装webbench进行接口压力测试/","link":"","permalink":"http://yoursite.com/blog/2018/06/01/java/Mac环境下，安装webbench进行接口压力测试/","excerpt":"","text":"123456brew install ctags # 依赖安装wget http://blog.zyan.cc/soft/linux/webbench/webbench-1.5.tar.gztar -zxvf webbench-1.5.tar.gzcd webbench-1.5mkdir -pv /usr/local/man/man1 # 必须sudo make &amp;&amp; sudo make install # sudo 权限因为需要创建文件夹 测试","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/blog/tags/web/"}]},{"title":"","slug":"游戏评论/2018-05-26","date":"2018-05-25T16:59:02.987Z","updated":"2018-05-25T16:59:08.245Z","comments":true,"path":"2018/05/26/游戏评论/2018-05-26/","link":"","permalink":"http://yoursite.com/blog/2018/05/26/游戏评论/2018-05-26/","excerpt":"","text":"# 在说游戏是艺术还是好玩的，就好像说文学是艺术还是好看的，音乐是艺术还是好听的，绘画是艺术还是好看的。艺术和好玩本身就没有矛盾，上面一句就体现了游戏与其他艺术的一些相似。也可以说让一个游戏好玩本身就是艺术。音乐不是只有古典音乐才是艺术，绘画只有卢浮宫等级才是艺术，艺术本身就是拿来享受的。游戏与这些艺术形式相比并没有什么不同。我认为艺术的核心是技巧和心思设计的投入，传达思想，撩拨情感，创造美。好玩和让人感到刺激就属于撩拨情感的方面。但一般说xx是艺术是说具有深度，做的透彻，达到了一定高度，甚至可以长久反复体验。而cod就做的不够了，至少其撩拨情感并不值得长期反复体验。一些徒有画面的游戏也是如此，只能说图像引擎软件好，制作者并没有投入足够的心思和工作在应有的方面。艺术本与时间无关，只是这些内涵被长久广泛认同就成为了艺术经典罢了。什么是艺术同样也取决于欣赏者，能欣赏到多少作者的技巧心思和设计。对于某游戏，核心玩家就能从玩家的角度欣赏到优秀巨量的美术设计，精雕细刻的模型，精心编排的音乐，流畅自然的动作，一套精心设计的兼顾节奏画面深度的战斗系统和规则，设定宏大情感丰富的剧情等等，从游戏制作者角度会感受到一个时代的逆天优化，游戏系统的精心调整，程序细节的精致，以至于数学层面上的美，专用引擎软件的精心设计。但对于快餐玩家只能体验到表层的内容，说画面缩水，战斗无脑，自由度低，剧情烂！这里不是说快餐玩家不对，此游戏的确在这些方面做得不好。只是如果不能深入的体验任何形式的作品，那么任何作品能带来的享受都很有限，任何作品都不能带来艺术感，艺术也就成了那些距离(你)生活遥远的“不明觉厉”的东西的代名词。","categories":[],"tags":[]},{"title":"","slug":"java/String s = \"123\"; 与 String s = new String(\"123\")","date":"2018-05-21T15:40:43.000Z","updated":"2018-05-21T15:48:31.000Z","comments":true,"path":"2018/05/21/java/String s = \"123\"; 与 String s = new String(\"123\")/","link":"","permalink":"http://yoursite.com/blog/2018/05/21/java/String s = \"123\"; 与 String s = new String(\"123\")/","excerpt":"","text":"String s = “123”; 与 String s = new String(“123”); 首先我们要明白String s = new String(&quot;123&quot;);创建了几个对象。 创建了两个 语句”123”创建了一个对象，这是在java里唯一不需要new就能创建对象的 new String(“123”)又创建了一个对象 但他们有本质的区别，他们存放的地方不一样。”123”是存放在栈内存中的，用new创建的对象都是在堆内存中 对下面例子能给出正确结果的话，对两个的区别就应该差不多了解了。 123456789101112131415public class StringText &#123; public static void main(String[] args)&#123; String s1,s2,s3,s4; s1 = new String(\"123\"); s2 = new String(\"123\"); s3 = \"123\"; s4 = \"123\"; System.out.println(s1.equals(s2)); System.out.println(s3.equals(s4)); System.out.println(s1==s2); System.out.println(s3==s4); &#125; &#125;上面的结果是true/true/false/true. String s=&quot;abce&quot;;是一种非常特殊的形式,和new有本质的区别: 它是java中唯一不需要new就可以产生对象的途径 以 String s=&quot;abce&quot;;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中. 这种形式的字符串,在JVM内部发生字符串拘留,即当声明这样的一个字符串后,JVM会在常量池中先查找有有没有一个值为&quot;abcd&quot;的对象,如果有,就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象,如果没有,则在常量池中新创建一个”abcd”,下一次如果有String s1 = “abcd”;又会将s1指向&quot;abcd&quot;这个对象,即以这形式声明的字符串,只要值相等,任何多个引用都指向同一对象.","categories":[],"tags":[]},{"title":"","slug":"java/char型变量中能不能存贮一个中文汉字?为什么?","date":"2018-05-20T16:06:17.897Z","updated":"2018-05-20T16:27:08.869Z","comments":true,"path":"2018/05/21/java/char型变量中能不能存贮一个中文汉字?为什么?/","link":"","permalink":"http://yoursite.com/blog/2018/05/21/java/char型变量中能不能存贮一个中文汉字?为什么?/","excerpt":"","text":"char型变量中能不能存贮一个中文汉字?为什么? char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字， 所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。 补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 12345678910public class Text&#123; public static void main(String[] args) &#123; char ch = '中'; System.out.println(\"char:\" + ch); int max = Character.MAX_VALUE; int min = Character.MIN_VALUE; System.out.println(min + \"&lt;char&lt;\" + max);// 0&lt;char&lt;65535 &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"java/Java中的String，StringBuilder，StringBuffer三者的区别","date":"2018-05-20T15:28:28.477Z","updated":"2018-05-20T15:41:26.480Z","comments":true,"path":"2018/05/20/java/Java中的String，StringBuilder，StringBuffer三者的区别/","link":"","permalink":"http://yoursite.com/blog/2018/05/20/java/Java中的String，StringBuilder，StringBuffer三者的区别/","excerpt":"","text":"一、首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String String最慢的原因: String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。 12341 String str=\"abc\";2 System.out.println(str);3 str=str+\"de\";4 System.out.println(str); 如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的: 首先创建一个String对象str，并把“abc”赋值给str， 然后在第三行中，其实JVM又创建了一个新的对象也名为str， 然后再把原来的str的值和“de”加起来再赋值给新的str， 而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了， 所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。 所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。 注意：String str=&quot;abc&quot;+&quot;de&quot;; //在编译时会转换成String str = “abcde”; 二、线程安全 在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。 三、总结 String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况","categories":[],"tags":[]},{"title":"","slug":"java/java中reader和inputstream区别","date":"2018-05-20T12:56:04.924Z","updated":"2018-05-20T13:02:28.353Z","comments":true,"path":"2018/05/20/java/java中reader和inputstream区别/","link":"","permalink":"http://yoursite.com/blog/2018/05/20/java/java中reader和inputstream区别/","excerpt":"","text":"java中reader和inputstream区别java.io下面有两个抽象类：InputStream和Reader InputStream是表示字节输入流的所有类的超类 12InputStream | __FileInputStream Reader是用于读取字符流的抽象类 1234Reader |——BufferedReader |___InputStreamReader |__FileReader InputStream提供的是字节流的读取，而非文本读取，这是和Reader类的根本区别。即用Reader读取出来的是char数组或者String ，使用InputStream读取出来的是byte数组。","categories":[],"tags":[]},{"title":"阿里java面试题","slug":"java/阿里java面试题总结","date":"2018-05-16T16:00:00.000Z","updated":"2018-05-20T16:23:53.736Z","comments":true,"path":"2018/05/17/java/阿里java面试题总结/","link":"","permalink":"http://yoursite.com/blog/2018/05/17/java/阿里java面试题总结/","excerpt":"","text":"#面试题 String和StringBuffer的区别 gc的概念，如果A和B对象循环引用，是否可以被GC？ Java中的内存溢出是如何造成的 String s = “123”;这个语句有几个对象产生 Error、Exception和RuntimeException的区别，作用又是什么？ 列举3个以上的RuntimeException reader和inputstream区别 hashCode的作用 Object类中有哪些方法，列举3个以上（可以引导） char型变量中能不能存贮一个中文汉字?为什么? 列举几个Java Collection类库中的常用类 List、Set、Map是否都继承自Collection接口？ HashMap和Hashtable的区别 HashMap中是否任何对象都可以做为key,用户自定义对象做为key有没有什么要求？ interface 和 abstrat class的区别 是否可以继承多个接口，是否可以继承多个抽象类 启动一个线程是用run()还是start()? 多线程有几种实现 同步和并发是如何解决的 什么叫守护线程，用什么方法实现守护线程（Thread.setDeamon()的含义） 如何停止一个线程？ 解释是一下什么是线程安全？举例说明一个线程不安全的例子。解释Synchronized关键字的作用。 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 了解过哪些JDK8的新特性，举例描述下相应的特性？ 对sql进行优化的原则有哪些？ servlet生命周期是生命与cgi的区别？ StringBuffer有什么优势？为什么快？ other 谈谈你对HashMap的理解，底层原理的基本实现，HashMap怎么解决碰撞问题的？ 开发中用了那些数据库？回答mysql，储存引擎有哪些？然后问了我悲观锁和乐观锁问题使用场景、分布式集群实现的原理。 springmvc和mybatis的工作原理，有没有看过底层源码？ 熟悉IO么？与NIO的区别，阻塞与非阻塞的区别 微信红包怎么实现。 海量数据分析。 线程安全和非线程安全。 HTTP2.0、thrift。 java反射应用分布式事务一致性。 nio的底层实现。 jvm基础是必问的，jvm GC原理，JVM怎么回收内存。 API接口与SDI接口的区别dubbo如何一条链接并发多个调用。 Dubbo的原理，序列化相关问题。 用过哪些中间件。 做过工作流引擎没有。 以前的工作经历，自己觉得出彩的地方 线程池的一些原理，锁的机制升降级 从系统层面考虑，分布式从哪些纬度考虑 Hadoop底层怎么实现 threadLocal，线程池，hashMap/hashTable/coccurentHashMap等 秒杀系统的设计 虚拟机，IO相关知识点 Linux的命令 一个整形数组，给定一个数，在数组中找出两个数的和等于这个数，并打印出来，我写的时间复杂度高，要求O(n)。 n个整数，找出连续的m个数加和是最大。 更重视开源技术 数据库锁隐原理 1000个线程同时运行，怎么防止不卡 并列的并发消费问题） 高并发量大的话怎么处理热点，数据等 如何获取一个本地服务器上可用的端口 流量控制相关问题 数据库TPS是多少，是否进行测试过 缓存击穿有哪些方案解决 Java怎么挖取回收器相关原理 Java的集合都有哪些，都有什么特点 分布式锁，redis缓存，spring aop，系统架构图，MySQL的特性 场景，同时给10万个人发工资，怎么样设计并发方案，能确保在1分钟内全部发完 打个比方会提出类似的场景","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/blog/tags/java/"}]},{"title":"java开源持久层框架","slug":"java/java开源持久层框架","date":"2018-05-11T13:36:36.000Z","updated":"2018-05-12T12:08:39.803Z","comments":true,"path":"2018/05/11/java/java开源持久层框架/","link":"","permalink":"http://yoursite.com/blog/2018/05/11/java/java开源持久层框架/","excerpt":"","text":"java开源持久层框架HibernateIBatisMyBatisSpring DataBuguMongoJPOXApache TorqueCastorJaxorJdbmpBeansSpeedoXORMApache CayenneTorqueVorutaJORM框架","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/blog/tags/java/"}]},{"title":"序列化和持久化的区别与联系","slug":"java/序列化和持久化的区别与联系","date":"2018-05-11T13:36:36.000Z","updated":"2018-05-12T13:37:56.605Z","comments":true,"path":"2018/05/11/java/序列化和持久化的区别与联系/","link":"","permalink":"http://yoursite.com/blog/2018/05/11/java/序列化和持久化的区别与联系/","excerpt":"","text":"序列化和持久化的区别与联系","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/blog/tags/java/"}]},{"title":"List、Map、Set区别","slug":"java/List、Map、Set区别","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:51:27.898Z","comments":true,"path":"2018/05/10/java/List、Map、Set区别/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/java/List、Map、Set区别/","excerpt":"","text":"# 列表（List）的元素是有 序、可重复 的； 集合（Set）的元素是无序、不可重复的。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/blog/tags/java/"}]},{"title":"sql语句中的Count()","slug":"数据库/sql语句中的Count()","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:57:38.420Z","comments":true,"path":"2018/05/10/数据库/sql语句中的Count()/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/数据库/sql语句中的Count()/","excerpt":"","text":"sql语句中的Count()1234Count(数字) //&#123;如Count(1)&#125;和Count(*)这两个实际意义是一样的 count(*)肯定是查全部的记录条数了 count(数字)，和count(*)效果一样，有几条记录就显示几 count(属性名)则查处的是属性名下面的非null数据的个数 count()则报错 错误码: 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘) from food’ at line 1","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/blog/tags/数据库/"}]},{"title":"MVC框架","slug":"设计模式/ MVC框架","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:59:30.783Z","comments":true,"path":"2018/05/10/设计模式/ MVC框架/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/设计模式/ MVC框架/","excerpt":"","text":"MVC框架是三层架构：模式层、视图层、控制层模式层：表示企业数据和业务逻辑，是应用程序的主体部分； 视图层：是用户看到的并与之交互的界面； 控制层：接收用户的输入并调用模型和视图去完成用户的需求；属于和数据库相关操作是在模式层。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/blog/tags/设计模式/"}]},{"title":"将JAVABEAN对象转化成MAP","slug":"java/将JAVABEAN对象转化成MAP","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:52:38.994Z","comments":true,"path":"2018/05/10/java/将JAVABEAN对象转化成MAP/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/java/将JAVABEAN对象转化成MAP/","excerpt":"","text":"将JAVABEAN对象转化成MAP1234567891011121314151617181920212223242526272829303132package com.dongnengyu.mybatis_test2.service;/** * 董能宇 (dongnengyu@gmail.com) * 2018/3/25 */import org.apache.commons.beanutils.PropertyUtilsBean;import java.beans.PropertyDescriptor;import java.util.HashMap;import java.util.Map;public class JavaBeanUtil &#123; //将javaBean对象转化成Map public Map&lt;String, Object&gt; beanToMap(Object obj) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(0); try &#123; PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean(); PropertyDescriptor[] descriptors = propertyUtilsBean.getPropertyDescriptors(obj); for (int i = 0; i &lt; descriptors.length; i++) &#123; String name = descriptors[i].getName(); if (!\"class\".equals(name)) &#123; params.put(name, propertyUtilsBean.getNestedProperty(obj, name)); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return params; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/blog/tags/java/"}]},{"title":"数据库ACID","slug":"数据库/数据库ACID","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:56:22.836Z","comments":true,"path":"2018/05/10/数据库/数据库ACID/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/数据库/数据库ACID/","excerpt":"","text":"数据库ACID精简版 （1）原子性（Atomic）一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。实现事务的原子性，要支持回滚操作，在某个操作失败后，回滚到事务执行之前的状态。 （2）一致性（Consistency）一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度 （3）隔离性（Isolation）并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据。 （4）持久性（Durability）事务提交后，对系统的影响是永久的 详细版 （1）原子性编辑整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 （2）一致性编辑一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性 （3）隔离性编辑隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 （4） 持久性编辑在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，要正确实现ACID并不容易。ACID建议数据库将所有需要更新以及修改的资料一次操作完毕，但实际上并不可行。 （5）目前主要有两种方式实现ACID： 第一种是Write ahead logging，也就是日志式的方式(现代数据库均基于这种方式)。 第二种是Shadow paging。 相对于WAL（write ahead logging）技术，shadow paging技术实现起来比较简单，消除了写日志记录的开销恢复的速度也快(不需要redo和undo)。shadow paging的缺点就是事务提交时要输出多个块，这使得提交的开销很大，而且以块为单位，很难应用到允许多个事务并发执行的情况——这是它致命的缺点。 WAL 的中心思想是对数据文件 的修改（它们是表和索引的载体）必须是只能发生在这些修改已经 记录了日志之后 – 也就是说，在日志记录冲刷到永久存储器之后． 如果我们遵循这个过程，那么我们就不需要在每次事务提交的时候 都把数据页冲刷到磁盘，因为我们知道在出现崩溃的情况下， 我们可以用日志来恢复数据库：任何尚未附加到数据页的记录 都将先从日志记录中重做（这叫向前滚动恢复，也叫做 REDO） 然后那些未提交的事务做的修改将被从数据页中删除 （这叫向后滚动恢复 - UNDO）。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/blog/tags/数据库/"}]},{"title":"关于跨平台的认识","slug":"操作系统/关于跨平台的认识","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:55:15.021Z","comments":true,"path":"2018/05/10/操作系统/关于跨平台的认识/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/操作系统/关于跨平台的认识/","excerpt":"","text":"C为什么不能跨平台咱们先来讨论一下，C语言的执行过程，从而搞清楚为什么C语言不能跨平台。 12345678//@author www.yaoxiaowen.com 转载文章请注明出处。// 本文地址：http://www.cnblogs.com/yaoxiaowen/p/7470460.html #include &lt;stdio.h&gt;int main()&#123; printf(\"Hello, World!\"); return 0;&#125; 我们知道，计算机只认识0和1(就是二进制)，换句话说，不管我们在计算机上干了什么事情，运行了多么复杂的程序，从ps绘图，到qq聊天，再到听音乐，最终到了CPU的执行层面，其实就是 一串串的0和1组成的指令罢了。 当然，到了硬件层面，那就是与或非门的领域了。但是，上面的那个 hello world程序是怎么转换为0和1的呢。一般情况下，对于我们使用的是 IDE，比如 Visual Studio， CodeBlocks之类的，就是点击个运行按钮那么简单，或者你就是使用了gcc命令行来进行编译，也可以一行命令 gcc -o hello hello.c,就 输出了最后的编译结果。但是实际上，hello world的编译过程是这样的: 我们分阶段来讨论: 预处理阶段。预处理器(cpp)来把 代码中#开头的行进行展开， 比如头文件，宏等内容，修改最初的C文件。编译阶段。编译器(ccl)将修改后的C文件，翻译成了 另一文本文件，hello.s，这就是我们所说的汇编程序了。 打开这个文本文件内容 类似下面的格式： 123456789101112131415161718//@author www.yaoxiaowen.com 转载文章请注明出处。// 本文地址：http://www.cnblogs.com/yaoxiaowen/p/7470460.html section .data msg db &apos;Hello, world!&apos;,0xA len equ $-msg section .text global _start _start: mov edx,len mov ecx,msg mov ebx,1 mov eax,4 int 0x80 mov ebx,0 mov eax,1 int 0x80 当然，不同CPU和平台环境，编译输出的汇编代码也不同，我们这里仅作为示例。 汇编阶段。汇编器(as)将hello.s翻译成机器语言指令。 把这些命令打包成一种叫做可重定位目标程序(relocatable object program)的格式，此时的输出格式就是hello.o了。这其实就是二进制文件了。链接阶段。编译过程最后还有一个链接阶段(程序调用了 printf函数)，最后的输出结果还是和上一步类似，都是直接二进制文件。 了解了 hello world程序的编译过程，我们就来讨论一下，什么是汇编程序。 汇编语言（英语：assembly language）是一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。 什么是汇编，相关专业的同学应该都明白，因为计算机只认识0和1(就是二进制)，所以在计算机刚开始发明时，那些科学家们就是直接 向计算机输入0和1，来运行计算任务的。(当然，他们是通过穿孔纸带的方式来向计算机输入, 比如有孔代表1，没孔代表0)。通过这样的方式，计算机终于能运行了，但是这样的效率实在太慢了。 而在他们输入的0和1中，有些代表的是指令，这些是有固定含义和编码的。也是芯片能识别的。而另一些是数据。这些不同的程序的数据自然是不同的。我们前面就说，不管多么复杂的计算机操作，到了cpu级别都是0和1，数据虽然多变，但是 指令的数量是有限的。因为 指令是要被芯片固定识别的。芯片中要用 晶体管(最初是电子管)组成的与或非门组合来识别这些指令和数据。因为直接输入0和1,实在太繁琐了，所以他们就发明了汇编语言。来简化 程序的编写。 比如 计算 1+1，两个数据1都使用 0x0001 来表示，而 加操作，放在cpu中，可以是 0xa90df(这个是胡乱写的),这个二进制代表的加操作能被计算机识别。而因为这个加操作对于cpu来说，编码的0xa90df格式是固定的。所以可以直接一个助记符add来表示，这样科学家们写程序就方便多了，而这就是汇编程序的由来。因为汇编程序完成之后，可以再有一个专门的程序（就是要上文中所说的汇编器）来把编写的汇编程序编译成0和1.这样计算机也可以识别了，而汇编语言本身也方便了程序的编写和阅读。 编写汇编比直接编写二进制方便高效了太多。但是 随着计算任务的复杂，程序的规模越来越庞大，使用汇编程序也很累啊，那么是否有更简单的方式呢？所以科学家们发明了高级语言(比如 C,lisp等)，在编写程序的时候，使用C语言等编写，然后再使用 编译器将C语言程序翻译成汇编程序，汇编程序再使用汇编器编译成0和1，这样，cpu能识别的东西没有变化，但是对于编写程序的人，确实方便了很多。 通过以上的描述，我们就知道了高级语言的大概由来。也明白了我们所编写的各种高级语言，到了最后，其实都是转化为二进制执行。 而直接二进制格式的程序，我们称之为本地机器码(native code)。而类似那些 add之类的 助记符，以及汇编的编写格式或标准，我们称之为 指令集。 但是问题的关键来了。不同公司所生产的 cpu芯片。他们所使用的指令集不同啊, 这种芯片设计的事情，又不像TCP/IP协议那样，有国际统一的标准，甚至像intel所代表的复杂指令集，和arm为代表的精简指令集，它们指令集的设计思路就是不一样的。 所以 我们C语言最后编译出来的的二进制文件，假设是这段93034030930900090222ab2d11cd22dfad(随便写的)，不同的cpu上识别的意义是不同的。 所以为什么说C语言不能实现跨平台运行，就是因为它编译出来的 输出文件的格式，只适用于某种cpu，其他cpu不认识啊。 我们所说的跨平台运行，并不是指hell.c这个文本文件的运行。因为文本文件本身也没办法运行。运行的只是它的编译结果hello，而这个由0和1组成的编译结果，不同的cpu和平台，他们的格式不同。所以C语言编译出来的结果，没办法跨平台运行。甚至在不同的平台下，hello.c最后所编译出来的文件的格式都不同。比如linux下编译出的hello,window下编译结果是hello.exe,而mac下编译结果是hello.out,(至于单片机上编译结果的后缀是啥子，这个忘记了)。也有些人会讲，为了让linux下编写的一段hello程序运行在window上，我不拿最后的编译结果hello来直接运行，我在window环境下重新用IDE建立项目，同样的源代码在window下重新运行一遍，输出hello.exe，再在window上运行，行不行啊？这个答案是No。因为不同环境下，c语言的标准有差别。例如 int类型，在有的平台上 可能16位表示，而有的平台上则是32位表示。所以不同环境下的同一个程序，会存在数据溢出之类的错误。其实还有一点，大家平时写个程序，IDE上点击个run/build之类的，稍等一会就输出结果了，但是实际上，很多大型程序的编译过程是比较长的，比如我第一家公司做手机系统的，编译一个Android5.0的系统rom，在i7 cpu，16G内存的电脑上，需要编译运行一个多小时，才能编译成功输出最后的结果。知道了 C语言不能跨平台运行，那有没有一种办法，能够 让高级语言实现跨平台的运行呢? 思考实际编程中的一个场景，我们前端需要处理的某个数据是A格式，但是后台只能提供B格式的数据，那我们怎么办?很简单啊。写个接口，把B格式转化为A格式不就行了嘛。这就是设计模式当中的适配器设计模式。 关于跨平台也是一样的道理。cpu的指令集不同， 不同平台编译出来的结果格式都不同，那么我们可以在各个平台上运行虚拟机，然后我们制定某种编译结果的输出格式，我们的输出了某种格式的结果，直接在虚拟机上运行。这样不就ok了嘛。。 这其实就是 java采取的方式。 Class文件格式，虚拟机以及 ByteCode这是java版本的helloJava; 12345//@author www.yaoxiaowen.com 转载文章请注明出处。// 本文地址：http://www.cnblogs.com/yaoxiaowen/p/7470460.html public static void main(String[] args) &#123; System.out.println(\"helloJava\");&#125; 这段java程序编译出来的结果是 helloJava.class,换句话说，它输出的结果是Class文件格式(也叫字节码存储格式)。class文件的内容大概就像下面那样： 是不是看不懂?看不懂就对了。这其实就是java虚拟机定义的二进制格式，这种我们称之为 字节码(ByteCode),是java虚拟机所能运行的格式。类似本地机器码可以反编译成汇编，这种二进制也可以反编译成更容易阅读的格式。 类似下面这样。 而各个平台的java虚拟机 是不同的。但是我们编写的java程序 统一编译成特定格式的 Class文件格式，然后Class文件可以在各个不同平台的java虚拟机上运行,当然运行结果肯定也是一致的，至于各个不同平台之间的差异，这是那些编写java虚拟机的人去考虑的事情，我们这些做java的程序员，不用去关心这个问题。 通过这种方式，我们的java程序就实现了跨平台。 所以java也被称为 中间件技术语言。意思就是 中间加一层过度。很好理解。（当然，维基百科上对中间件技术的解释，基本把我看晕了,也和java没关系，不过大家理解这个意思就好）。 平台无关性而通过java虚拟机和Class文件格式，我们就实现了平台无关性,换句话说，这些适应各个不同平台和cpu的工作的还是要有人干的。那就是设计java虚拟机的人去做这些工作，但是他们的辛苦换来了我们上层程序员的轻松。我们就完全不关心各个平台和cpu的差异了。 代码编译的结果，从本地机器码（NativeCode）向字节码(ByteCode)的转变，是存储格式的一小步，却是编程语言发展的一大步 虽然说名字是 ByteCode,但是我觉的，其实和 NaticeCode 都差不多，反正都是定义了一套指令集，只是前者能被虚拟机执行引擎去执行，而 后者能被物理机的CPU去执行罢了。 知道了大概的原理，我们就思考另一个问题，java虚拟机去执行Class文件，那和java的源文件 有什么关系呢。答案是 没关系。换句话说，java的源文件编译的输出结果为Class文件，而Class文件能被java虚拟机认识，并执行，这是两个独立的过程，中间也没啥关系和必然性。 那么进而引申出另一个问题，某一种其他编程语言，如果我设计出了一种对应的编译器，将其编译输出结果为Class文件，那这样该语言岂不是也实现了跨平台了? 想到这一点，那么恭喜你，你发现了 java虚拟机的另一种 重要特性。语言无关性 语言无关性java虚拟机在执行Class文件时，不知道也完全不关心这个Class文件是咋来的。(这个Class文件可以是任何一种语言的源文件编译而来，当然，就像直接编写汇编一样，你直接编写 ByteCode也行,只要格式正确)。其实CPU在执行二进制的指令时，它不知道也完全不关心这些指令流是咋来的。这都是同一个道理。 很多程序员都还认为Java虚拟机执行Java程序是一件理所当然和天经地义的事情。这是错误的。 下面某些内容 援引 周志明的 《深入理解java虚拟机》： Sun的开发设计团队在最初设计的时候就把Java的规范拆分成了Java语言规范《The Java Language Specification》及Java虚拟机规范《The Java Virtual Machine Specification》。 并且在1997年发布的第一版Java虚拟机规范中就曾经承诺过：“In the future,we will consider bounded extensions to the Java virtual machine to provide better support for other languages”（在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于JVM之上）。 实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任何一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。 换句话说，java虚拟机这个名字其实只是一个误导，java虚拟机和java没啥关系，其实更应该叫做 Class文件虚拟机。 因为其他语言， 只要有对应的编译器，输出结果就可以运行在java虚拟机上，所以时至今日,涌现Clojure、Groovy、JRuby、Jython、Scala一批运行在java虚拟机上的语言。 目前下图中的语言都已经可以运行在java虚拟机上。 所以广义上的java技术体系，也包括Clojure、JRuby、Groovy,Scale等运行于Java虚拟机上的语言及其相关的程序。 Java,Scale等各种语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比单一语言本身更加强大。 当然，在java最初刚出现的时候，Write Once，Run Anywhere, 这种 平台无关性被吹嘘的比较厉害，但是现在 这种虚拟机的思想，被很多其他语言也学会了，比如python和pvm。go语言，.NET等都是同样的思想。 为什么C/C++没有被替代。关于java虚拟机和Class文件格式， 貌似很厉害的样子，什么 个人一小步，人类一大步都扯上了，那肯定有人疑问，为什么 c/c++这些不能跨平台的语言，还现在还被很多人使用，还没被java取代呢。 当然，这个原因有很多，比如java的gc过程所无法避免的stop the world过程，这在 某些实时性要求比较高的 系统中，比如 股票交易系统，军事系统，是不可接受的。(关于垃圾回收这是另一个话题，不在本文范围内，未来有时间可以花时间另写博客讨论这个问题)。 不过有句话说的很好java和c++之间有一堵由动态内存分配和垃圾收集技术所围成的’高墙’，墙外的人想进去，墙内的人想出来 另外，对于直接与硬件交互的事情，也只能靠C语言了。毕竟上层再怎么发展，硬件与系统之间永远要存在一个驱动层啊。 但是除了以上这些，还有一个原因。给大家讲讲软件历史上的一个重大教训，大家也许就明白了。 当年为了对抗sun的java平台，微软2002年推出了类似中间件思想的.NET平台(C#)。当时window xp一统江湖，让微软如日中天，不可一世，微软在下一代操作系统(就是window visa)的开发中，决定使用 C#， 虽然微软牛逼哄哄，拥有最牛逼的程序员，最顶尖的科学家，但是开发到最后他们发现，使用C#这种运行在虚拟机上的中间件语言，无论如何也达不到 C/C++语言的速度。所以最后悲剧的 window visa，全部推倒重来，重新开发。当时李开复在微软，他的一本书中对此有详细介绍。 当然，当年window visa项目的失败，还有其他一些原因，比如 使用数据库系统代替文件系统，驱动不兼容等， 但是 使用.NET来进行开发，起码也是失败的主要原因之一。 所以现在大家明白了，ByteCode运行在虚拟机上，相比于直接编译成 NativeCode 运行在物理机上，速度较慢。 现在随着虚拟机运行时优化技术的发展，以及硬件的速度越来越快，所以它们速度之间的差异，也没之前差距那么大了。 实质上，Class文件在虚拟机上运行的时候，还会有很多的优化措施。 在部分的商用虚拟机中，Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，简称JIT编译器）。 许多主流的商用虚拟机都同时包含解释器与编译器。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。 但是实际上，编译器可以把java源文件的输出结果编译成Class格式(也就是 ByteCode)，那自然也可以有其他类型的编译器 可以直接将java源文件编译为NativeCode啊。所以对于编程语言来说，我们可以有各种方式来编译它，Java语言的“编译期”其实是一段“不确定”的操作过程。因为我们可以使用不同类型的编译器编译出不同的输出结果。 java常见的编译器有以下类型。 前端编译器：把.java文件转变成.class文件。比如Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。JIT编译器：字节码(ByteCode)转变成机器码(NaticeCode)。比如HotSpot VM的C1、C2编译器。AOT编译器：直接把*.java文件编译成本地机器代码。 比如GNU Compiler for the Java（GCJ）、Excelsior JET。结束所以讨论到最后，大家就已经明白，所以平台无关性，与 编译器与编译输出结果格式 的关系。花了一天时间写了这么多内容，也希望给大家带来一些启发。 在本篇博客当中，很多内容也并不是精确的分析，比如某些概念，都说的比较模糊，因为我们这片博客只是讨论思想。很多概念和过程也都没有去深究, 如有错误不准确的地方，欢迎指正。 补充内容（20170905）非常感谢大家对这篇文章的支持，能够对其他人有所帮助，获得大家的认可。更加提升了我坚持写博客的动力。 针对评论中的问题，也进行一些解答。 一 如文章末尾所说，我本来就是写大概思想，所以很多细节没有深入去追究，其实比如像汇编的格式，指令集的执行等，其实这些讨论起来真心复杂，牵扯到cpu的结构设计等。今后也计划写文章和大家讨论这些问题。 评论中倒没有人指出这方面的问题，不过我大学时本来就是做C语言和单片机的，明白这方面介绍的依旧不够准确和详细。（当然，很多细节我也忘记了） 二 评论当中有人提到.NET的虚拟机的问题，首先因为我本身是Android程序员，大学时期也做过C语言，单片机等，所以对java，C等算是了解一些，但是对.NET的确不了解。对.NET有限的知识，也来源于和做.NET的朋友的讨论交流。因此关于.NET思想的评价可能不够准确。 评论中有人提出了以下问题： wdwwtzy 评论： 那我想问问，.net 也是 java 一样的虚拟机技术，为什么早期.net 无法跨平台？隆德尔评论：楼主，据我所知，java与.net，此虚拟机非彼虚拟机。而且这个问题一直被很多javaer所混淆。wdwwtzy评论：啥意思，看文章的意思，java 一出生不就是真正的跨平台了吗？ 有些同学直接评论做了相关解答，对此深表感谢。写博客本来就是一个相互讨论相互促进的过程，所以感谢各位的解答。 WindyAmy评论：.net CLR/.net framework 和window系统结合的太紧密导致。现在微软重写了部分framework库（.net core），已经可以实现夸平台了。Blackheart评论：因为没有人在其他平台实现.net 的clr啊，后来有了mono，可以跨平台了。没有真正意义上的跨平台，对于开发者而已，可能你不需要关心操作系统是windows还是linux了，你感觉是跨平台了。但是底层总有这么一帮人在帮你搭建支撑“跨平台”的基础设施的，对于他们来说，一个个的平台都需要单独去实现的。** 几位解答的同学说的都已经非常好了，本人结合评论，也google了一些相关知识。再对.NET的相关问题写出我的理解。以期抛砖引玉。 可以确定是，.NET和java虚拟机也是一样的思想，都是引入中间层/虚拟机的思想。做java的同学说java虚拟机（JVM），而微软的.NET的虚拟机的名称叫做通用语言运行平台（Common Language Runtime，简称CLR）。虽然有些同学可能认为CLR不叫虚拟机，但是归根到底，它还是广义的虚拟机的概念和思想。 Clojure、Groovy、JRuby、Jython、Scala等很多语言都可以运行在JVM上。而 CLR也是一样的，C#、F#、VB.NET、C++、Python等几十种语言也可以运行在CLR上。 java，Scala等编译结果为ByteCode(字节码),被称之为Class文件格式运行在jvm上，而jvm在运行Class格式文件时，可以解释运行，也可以通过JIT编译器编译成NativeCode加快运行。而C#，C++等编译成 通用中间语言（Common Intermediate Language，简称CIL）,然后再汇编成字节码，（当然这个字节码肯定不会是Class文件格式，但是概念相同），而在运行时，也是翻译成本地机器码运行（但是CLR貌似没有解释运行，这点求相关同学解答，我估计应该也有类似javascript的解释运行方式，不过没查到相关资料）。 以上是技术层面，下面我们再来讨论 一些非技术层面。 大家知道，我们要想在某个平台上运行java开发的项目，必须要安装jdk，这个过程还是很麻烦的，要设置环境变量之类的。这对于普通用户来讲是不可能完成的操作。而.NET其实也是需要安装环境的（叫做 .NET framework），但是window就是微软自家的，所以window系统内置了.NET framewok。(win7自带.net3.5版本,win10自带4.0版本)，所以window上本来就可以运行.NET的程序。省去了普通用户安装.NET framework的麻烦。 但是微软肯定不会为window内置jdk的，原因太简单了，如果window也都内置了jdk，而其他的linux，mac等操作系统也都进行内置，那么各个开发应用/游戏的厂商们，直接使用java开发就好了，然后开发出来的产品直接window/linux/mac所有系统平台上都通用，厂商们开心了，消费者也开心了，那这个时候，我们为什么还要使用window操作系统呢？反正对于普通消费者而言，使用应用或玩游戏都是没啥区别的。 （所以这也是为什么java在pc端应用/游戏领域没人使用，而服务器端使用java的多，因为开发服务器的码农们搭配java环境很easy啊） 回想一下 window与Netscape的浏览器大战，如果使用浏览器就能干大部分事情，那么大家根本就不关心运行浏览器的操作系统是window还是linux了。当然，现在互联网的流量/入口之争其实都是同一个道理。普通消费者哪里关心那么多，哪个好用，哪个便宜就用那个。 2014年11月12日，微软宣布将完全开放.NET框架的源代码，并提供给Linux和OS X使用。 首先本博客当中非常清晰的表达了这个观点，什么跨平台不跨平台，适应各个平台/CPU的差异，这种脏活累活永远也得有人干，只是那些 去做虚拟机的人干了这种活，我们这种纯粹写上层的人轻松了而已。 所以我觉的很多时候，能不能跨平台，除了技术问题，还要有商业原因，甚至也有money的问题（毕竟开发各个平台的虚拟机也是不易）。就像 .NET理论上跨平台，但是不开源，几年前微软又不肯为.NET提供linux环境下的实现。那么自然没办法跨平台，但是这和技术无关。 java最初设计时，理论上就可以跨平台，但是那些苦逼的虚拟机开发者们还要去开发各个平台/cpu的虚拟机，这也不是一朝一夕之功。 微软现在可以让.NET跨平台，一来大的形势变了（之前的操作系统卖的那么贵，现在win10都可以免费了）,二来微软对.NET有控制权。而在java刚出来的时候，微软也支持java，也设计过微软版本的jvm。但是微软是想拥有对java技术体系的控制权，但是发现搞不过sun之类的，java不在它的控制之下，所以微软就开始搞自己的.NET平台了。 也许Java程序员听起来可能会觉得惊讶，微软公司曾经是Java技术的铁杆支持者（也必须承认，与Sun公司争夺Java的控制权，令Java从跨平台技术变为绑定在Windows上的技术是微软公司的主要目的）。在Java语言诞生的初期，微软公司为了在IE3中支持Java Applets应用而开发了自己的Java虚拟机，虽然这款虚拟机只有Windows平台的版本，却是当时Windows下性能最好的Java虚拟机。但好景不长，在1997年10月，Sun公司正式以侵犯商标、不正当竞争等罪名控告微软公司，在随后对微软公司的垄断调查之中，这款虚拟机也曾作为证据之一被呈送法庭。这场官司的结果是微软公司赔偿2000万美金给Sun公司（最终微软公司因垄断赔偿给Sun公司的总金额高达10亿美元），承诺终止其Java虚拟机的发展，并逐步在产品中移除Java虚拟机相关功能。具有讽刺意味的是，到最后在Windows XP SP3中Java虚拟机被完全抹去的时候，Sun公司却又到处登报希望微软公司不要这样做。Windows XP高级产品经理Jim Cullinan称：“我们花费了3年的时间和Sun打官司，当时他们试图阻止我们在Windows中支持Java，现在我们这样做了，可他们又在抱怨，这太具有讽刺意味了。”","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/blog/tags/操作系统/"}]},{"title":"Markdown嵌入图片","slug":"MWeb/Markdown嵌入图片","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:50:43.868Z","comments":true,"path":"2018/05/10/MWeb/Markdown嵌入图片/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/MWeb/Markdown嵌入图片/","excerpt":"","text":"Markdown嵌入图片将图片嵌入Markdown文档中一直是一个比较麻烦的事情。通常的做法是将图片存入本地某个路径或者网络存储空间，使用URL链接的形式插入图片： ![image][url_to_image] 这样做一个明显的麻烦之处在于处理图片与Markdown文档的一致性上。如果我们要拷贝文档，或者图片遭到误删/云端链接失效，就会变得不便。最让我们省心的方法便是将图片直接放到文档内部。 一个将图片嵌入文档中的方法是使用base64编码。步骤比较简单： 将图片或截图保存在本地； 使用在线工具将图片转码至base64编码；(link1, link2)； 在文档中插入编码： 1![image][data:image/png;base64, ......] 当然base64编码一般很长，直接将编码放入段落内部会影响正常编辑。通常的做法是将base64编码定义到一个中间变量中，将编码本体放到文档末： 1234![image][tmp]your document here ...[tmp]:data:image/png;base64, ...... 使用该技巧的时候需要注意，并不是所有的Markdown编辑器都支持这种方法。而且一些Markdown编辑器只支持特定的图片格式。如有道云笔记只支持png格式的图片编码。需要在保存图片文件的时候加以注意。","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/blog/tags/Markdown/"}]},{"title":"舌尖上的中国3影评","slug":"影评/舌尖上的中国3影评","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:56:00.571Z","comments":true,"path":"2018/05/10/影评/舌尖上的中国3影评/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/影评/舌尖上的中国3影评/","excerpt":"","text":"舌尖上的中国3影评 把糟粕当做文化。把落后当做质朴。把迷信当做传统。把反智当做精华。几年前舌尖第一部横空出世，看完我会觉得“中国好吃的可真多”。再后来出了舌尖二，让我觉得“没用的废话可真多”。这部舌尖三看完几集，顿时觉得“中国落后的地方可真多”。全篇都是在宣扬愚昧和落后的生产方式，加之玄之又玄的忽悠，仿佛有一种传销的即视感。就好像某“导师”在台上给学员们介绍手中产品：“我这个锅，底是圆的，铲子是方的，体现了天圆地方的道家真理！前后两个把手，象征稳抓经济两手都要硬！滴两滴油，放一瓣蒜，象征2学1做的方针！我这个锅每个铁分子（经大家提醒应该是铁原子，化学知识都还给老师了……）都饱含大自然的气息，并且与宇宙引力波形成共振，吸收日月精华！用这口锅炒菜，不仅补铁补气补查克拉，背着锅出去旅行还能延年益寿！”大大前年笑话完台湾用爱发电，大前年我们笑话完朴槿惠信邪教，前年笑话完雷雷太极大师，去年笑话完日本的大忽悠煮饭仙人，今年我们又紧紧跟随反智的脚步，果然是【自古出神棍，东亚尤其多】 作者：湿身人面酱链接：https://www.zhihu.com/question/63393032/answer/324965613来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 有一个令人警惕的地方，节目里宣称西安回坊自唐朝就开始形成了。可实际上那时候根本没有什么回民。在舌尖上的中国这种美食类节目里，这个说法也许只是一个小错误。但是联系现在国内蔓延开来的泛清真化，更兼清真盐清真牛奶等等早已悄无声息地改变了很多人的生活，宗教势力抬头已无法遏制。傅统先《中国回教史》、金吉堂《中国回教史研究》、马以愚《中国回教史鉴》、邱树森《中国回族史》这些穆斯林已经开始明目张胆地篡改历史，如将一系列出身汉族的历史人物如朱元璋海瑞，划归于回族，如将回族马步芳等人一一洗白。一场有预谋的布局早就开始了。2018年央视狗年春晚，公然将尚存争议的涉及穆斯林地图宣布为丝路山水图，更是罔顾事实，直接指鹿为马喊出终点为伊斯兰圣地麦加。莫非不知正是伊斯兰毁灭了途径丝绸之路的那些中亚小国？（24日更新，此画原名涉疑，内容也涉疑，改之）文化渗透恐怖至斯！那么，这个又一次在央视播出的，堂而皇之地将回民历史往前推了一千年的说法，日后真的只是一个小错误么？ 作者：晏公子链接：https://www.zhihu.com/question/63393032/answer/323960751来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"影评","slug":"影评","permalink":"http://yoursite.com/blog/tags/影评/"}]},{"title":"HIbernate和Mybatis优缺点对比","slug":"java/HIbernate和Mybatis优缺点对比","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:53:07.657Z","comments":true,"path":"2018/05/10/java/HIbernate和Mybatis优缺点对比/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/java/HIbernate和Mybatis优缺点对比/","excerpt":"","text":"HIbernate和Mybatis优缺点对比Hibernate的优点：1、hibernate是全自动，hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。 2、功能强大，数据库无关性好，O/R映射能力强，需要写的代码很少，开发速度很快。 3、有更好的二级缓存机制，可以使用第三方缓存。 4、数据库移植性良好。 5、hibernate拥有完整的日志系统，hibernate日志系统非常健全，涉及广泛，包括sql记录、关系异常、优化警告、缓存提示、脏数据警告等 Hibernate的缺点：1、学习门槛高，精通门槛更高，程序员如何设计O/R映射，在性能和对象模型之间如何取得平衡，以及怎样用好Hibernate方面需要的经验和能力都很强才行 2、hibernate的sql很多都是自动生成的，无法直接维护sql；虽然有hql查询，但功能还是不及sql强大，见到报表等变态需求时，hql查询要虚，也就是说hql查询是有局限的；hibernate虽然也支持原生sql查询，但开发模式上却与orm不同，需要转换思维，因此使用上有些不方便。总之写sql的灵活度上hibernate不及mybatis。 Mybatis的优点：1、易于上手和掌握，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。 2、sql写在xml里，便于统一管理和优化， 解除sql与程序代码的耦合。 3、提供映射标签，支持对象与数据库的orm字段关系映射 4、 提供对象关系映射标签，支持对象关系组建维护 5、提供xml标签，支持编写动态sql。 6、速度相对于Hibernate的速度较快 Mybatis的缺点：1、关联表多时，字段多的时候，sql工作量很大。 2、sql依赖于数据库，导致数据库移植性差。 3、由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。 4、对象关系映射标签和字段映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。 5、DAO层过于简单，对象组装的工作量较大。 6、不支持级联更新、级联删除。 7、Mybatis的日志除了基本记录功能外，其它功能薄弱很多。 8、编写动态sql时,不方便调试，尤其逻辑复杂时。 9、提供的写动态sql的xml标签功能简单，编写动态sql仍然受限，且可读性低。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/blog/tags/java/"}]},{"title":"数据库中什么是S锁？什么是X锁？它们区别是什么？","slug":"数据库/数据库中什么是S锁？什么是X锁？它们区别是什么？","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:57:31.036Z","comments":true,"path":"2018/05/10/数据库/数据库中什么是S锁？什么是X锁？它们区别是什么？/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/数据库/数据库中什么是S锁？什么是X锁？它们区别是什么？/","excerpt":"","text":"数据库中什么是S锁？什么是X锁？它们区别是什么？ 首先，mysql锁机制分为表级锁和行级锁 共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。的。 排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。 对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据，对于排他锁大家的理解可能就有些差别，我当初就犯了一个错误，以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。 排他锁指的是一个事务在一行数据加上排他锁后，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。 mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/blog/tags/数据库/"}]},{"title":"sleep和wait的区别","slug":"java/sleep和wait的区别","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:52:06.410Z","comments":true,"path":"2018/05/10/java/sleep和wait的区别/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/java/sleep和wait的区别/","excerpt":"","text":"sleep和wait的区别有： 1、这两个方法来自不同的类分别是Thread和Object 2、最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。 3、wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在 任何地方使用 1234synchronized(x)&#123; x.notify() //或者wait() &#125; 4、sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/blog/tags/java/"}]},{"title":"如有天置地门外，乘电车跨国大海 --《樱花树下》","slug":"乐评/樱花树下","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T13:45:02.137Z","comments":true,"path":"2018/05/10/乐评/樱花树下/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/乐评/樱花树下/","excerpt":"","text":"如有天置地门外，乘电车跨国大海 –《樱花树下》“置地门外”，中环的”置地广场” (Landmark)，而置地的门外（德辅道中）正正有一电车站，但是电车是香港岛的特有交通工具，并没有线路过海。至於电车如何跨过大海，我想只是很有意境的超现实写法而已。在置地广场外面搭电车过海，是个不可能的比喻。 后面承接”匆匆 跟你 相望一眼 没理睬”也算是林先生给人的一种慰藉吧 其实我觉得林先生很喜欢这种夸张、甚至超现实的写法，例如他很喜欢「一百岁」－－「如若一百岁我会找到他已不错」、「如果有生日期 等多一百岁亦等待你」、「见证你这个百岁的老翁」等等等等，一百岁也太少了，来个双倍「贪一个就当最佳的绝配 留待有二百岁至后悔」、「二百岁的少女 没有意识引退……活到了几百岁 直觉会更敏锐」，再然后「六百岁再梦见过往六岁」、「一出世注定要一起 等不到一千岁」。又他爱与月球谈恋爱（是月球，不是月亮），除《月球上的人》，还有「当樱花迫於迁往悄静月球」，现实中（至少现时这一刻）樱花也不可能迁往月球吧！","categories":[],"tags":[{"name":"乐评","slug":"乐评","permalink":"http://yoursite.com/blog/tags/乐评/"}]},{"title":"十个救火的少年","slug":"乐评/十个救火的少年","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T13:44:03.992Z","comments":true,"path":"2018/05/10/乐评/十个救火的少年/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/乐评/十个救火的少年/","excerpt":"","text":"十个救火的少年转载于http://cantonpopblog.blogspot.com/2015/04/blog-post_22.html 〈十個救火的少年〉由達明一派主唱，發行於1990年《神經》專輯。歷年在不同平台上備受討論及引用，論者常將之與六四事件扣連，說潘源良「以隱喻方式寫六四」，將之奉為「八九六四十歌曲」。然而，這只是時代賦予〈十個救火的少年〉的意義，並非詞人的本意，以下先釐清〈十個救火的少年〉與六四的關係，再探其內容的一二。 這首歌在諷刺人性弱點上是無從否定，而有否針對性則有待商榷。黃志華在2006年的網誌中提及，歌中反映「煩惱皆因強出頭」等負面的民族性，雖說「讓人想到六四事件前後的許許多多現實故事與人物」，但沒有指出歌曲的針對性，只表示歌詞令人產生聯想。但在2009年的訪問中，黃志華明言「這唱片(達明一派《神經》)寫得較含蓄，也因為在事件後半年才出版，當中有更多的反思。例如〈十個救火的少年〉，就寫到民運人士的潰散。」直接把歌曲內容與六四事件相連接，而在同一訪問中，潘國靈亦持相同的看法，認為對於六四事件，專輯《神經》是以「抽象隱晦」的方法表達。歌曲流傳下來，供大眾所聽，而時代的人當然會根據自己當前感覺，把情感投射在歌詞上，滿足自我期許，沒有對錯可言，只是偶然探索詞人的原意也無不可。 在2013年6月的電台節目〈音樂從呢道開始〉中，潘源良憶述，雖然確實創作原意已記不清楚，但此歌在六四事件發生前已開始構思，只因修訂、灌錄需時，才在六四後推出市場。一開始，是基於節奏與歌詞長度為考量，再決定以十個少年的寓言故事作為內容，而深沉主題是潘源良的一貫風格，但對於針對特定事件，詞人更認為歌曲是敘述整個社會的氣氛，甚至反問主持「其實反映六四哪部分？」。創作原意本來難以推敲，甚至詞人自己也難以說清，但我們亦能根據詞人的說法，排除一些可能性。 歌詞內容上，以嘉年華式的輕快節奏，訴說一個現實的寓言故事，反映人間百態及冷感。歌詞中的少年對於火災，大多採隔岸觀火的態度，第二節，十人「站立在橋邊」，第六段餘下七人，仍「集合在橋邊」，第八節只有四人「又有個願說郤不肯向前」，直至徘徊不前。人總離不開既有的安全界限，準備離開之時，就馬上忘了自己因聽到火警鐘聲，「志願」救火的初衷，趕忙回到情人、家人的身邊，不願冒險，而詞中各人的反應是每況愈下的。第一個「報了名」，算是精神上支持，第二個「靜悄」地離開，也算有慚愧之心，不敢大搖大擺地離開，此後的轉身就走、以吵架作為掩飾，所謂的「穩健成員」也是紙上談兵，沒有實際行動，最後大眾甚至「在怨」葬身火海的三人「用處沒有一點」，？歌詞呈現「等待」的含意，一眾人在橋邊等，沒有人前行，與六四向前推進的意識大相逕庭，十個人在等，然後慢慢離開，餘下的人，也不知道所等的是甚麼，只是苦苦的等待，然後被吞噬，面對這樣的社會，寧願茍且活下去，還是乾脆化身塵土？ 星火燎原，〈十個救火的少年〉是基於人為因素而釀成的後果，而不是意外。參考網絡資料，發現〈十個救火的少年〉應是根據阿嘉莎‧克莉絲蒂(Agatha Christie)1939年創作的 《十個小黑人》(Ten Little Niggers)中的童謠，改編而成。童謠的內容是有關九個印地安男孩，相繼因無妄之災死亡，最後一個男孩，不能承受來去一人的孤獨而懸樑自盡。而小說中的角色與童謠所敘述一樣，接連死去，有預言的作用。〈十個救火的少年〉既以此寓言包裝，不難發現詞人認為社會人情冷漠，會招致燎原性的惡果，少年在猛火當前，相互展示風度，沒有人願意先行，生怕先行者死，而最後三少年被大火吞噬後，眾說紛紜，無人同情，反而只管怪責，以事後孔明的姿態指指點點，詞中雖然沒有直接指出，但也明白「三減一得二」之後會是二減一得零，而童謠的末句「一個也不剩」，補足了歌詞的含意。這首歌的寄寓大概是，如果大家仍是大難臨頭各自飛，即使你比誰都冷漠無情，成為了社會上最後站立的人，但無法生存下去，因為你親身殺害了社會，沒有相對的人，其實你甚麼也不是。","categories":[],"tags":[{"name":"乐评","slug":"乐评","permalink":"http://yoursite.com/blog/tags/乐评/"}]},{"title":"数据库三种完整性","slug":"数据库/数据库三种完整性","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-10T15:57:46.788Z","comments":true,"path":"2018/05/10/数据库/数据库三种完整性/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/数据库/数据库三种完整性/","excerpt":"","text":"数据库三种完整性 域完整性：域完整性是对数据表中字段属性的约束，通常指数据的有效性,它包括字段的值域、字段的类型及字段的有效规则等约束，它是由确定关系结构时所定义的字段的属性决定的。限制数据类型,缺省值,规则,约束,是否可以为空,域完整性可以确保不会输入无效的值。 实体完整性：实体完整性是对关系中的记录唯一性，也就是主键的约束。准确地说，实体完整性是指关系中的主属性值不能为Null且不能有相同值。定义表中的所有行能唯一的标识,一般用主键,唯一索引 unique关键字,及identity属性比如说我们的身份证号码,可以唯一标识一个人。 参照完整性：参照完整性是对关系数据库中建立关联关系的数据表间数据参照引用的约束，也就是对外键的约束。准确地说，参照完整性是指关系中的外键必须是另一个关系的主键有效值，或者是NULL。参考完整性维护表间数据的有效性,完整性,通常通过建立外部键联系另一表的主键实现,还可以用触发器来维护参考完整性。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/blog/tags/数据库/"}]},{"title":"HIbernate框架面试题","slug":"java/HIbernate框架面试题","date":"2018-05-10T13:36:36.000Z","updated":"2018-05-12T15:35:54.695Z","comments":true,"path":"2018/05/10/java/HIbernate框架面试题/","link":"","permalink":"http://yoursite.com/blog/2018/05/10/java/HIbernate框架面试题/","excerpt":"","text":"1、什么是Hibernate的并发机制？怎么去处理并发问题？Hibernate并发机制： a、Hibernate的Session对象是非线程安全的,对于单个请求,单个会话,单个的工作单元(即单个事务,单个线程),它通常只使用一次, 然后就丢弃。 12345678如果一个Session 实例允许共享的话，那些支持并发运行的,例如Http request,session beans将会导致出现资源争用。 如果在Http Session中有hibernate的Session的话,就可能会出现同步访问Http Session。只要用户足够快的点击浏览器的“刷新”, 就会导致两个并发运行的线程使用同一个Session。 b、多个事务并发访问同一块资源,可能会引发第一类丢失更新，脏读，幻读，不可重复读，第二类丢失更新一系列的问题。 解决方案：设置事务隔离级别。Serializable：串行化。隔离级别最高Repeatable Read：可重复读Read Committed：已提交数据读Read Uncommitted：未提交数据读。隔离级别最差设置锁：乐观锁和悲观锁。乐观锁：使用版本号或时间戳来检测更新丢失,在的映射中设置 optimistic-lock=”all”可以在没有版本或者时间戳属性映射的情况下实现 版本检查，此时Hibernate将比较一行记录的每个字段的状态 行级悲观锁：Hibernate总是使用数据库的锁定机制，从不在内存中锁定对象！只要为JDBC连接指定一下隔 离级别，然后让数据库去搞定一切就够了。类LockMode 定义了Hibernate所需的不同的锁定级别：LockMode.UPGRADE,LockMode.UPGRADE_NOWAIT,LockMode.READ; 2、update和saveOrUpdate的区别？update()和saveOrUpdate()是用来对跨Session的PO进行状态管理的。update()方法操作的对象必须是持久化了的对象。也就是说，如果此对象在数据库中不存在的话，就不能使用update()方法。saveOrUpdate()方法操作的对象既可以使持久化了的，也可以使没有持久化的对象。如果是持久化了的对象调用saveOrUpdate()则会 更新数据库中的对象；如果是未持久化的对象使用此方法,则save到数据库中。 3、hibernate的三种状态之间如何转换当对象由瞬时状态(Transient)一save()时，就变成了持久化状态；当我们在Session里存储对象的时候，实际是在Session的Map里存了一份， 也就是它的缓存里放了一份，然后，又到数据库里存了一份，在缓存里这一份叫持久对象(Persistent)。 Session 一 Close()了,它的缓存也都关闭了,整个Session也就失效了,这个时候，这个对象变成了游离状态(Detached)，但数据库中还是存在的。当游离状态(Detached)update()时，又变为了持久状态(Persistent)。当持久状态(Persistent)delete()时，又变为了瞬时状态(Transient), 此时，数据库中没有与之对应的记录。 4、比较hibernate的三种检索策略优缺点1立即检索；优点： 对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象；缺点： 1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间；2延迟检索：优点： 由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间；缺点： 应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化；3 迫切左外连接检索优点： 1对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2使用了外连接，select语句数目少；缺点： 1 可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2复杂的数据库表连接也会影响检索性能； 5、如何在控制台看到hibernate生成并执行的sql在定义数据库和数据库属性的文件applicationConfig.xml里面，把hibernate.show_sql 设置为true这样生成的SQL就会在控制台出现了注意：这样做会加重系统的负担，不利于性能调优 6、hibernate都支持哪些缓存策略Read-only: 这种策略适用于那些频繁读取却不会更新的数据，这是目前为止最简单和最有效的缓存策略 Read/write:这种策略适用于需要被更新的数据，比read-only更耗费资源，在非JTA环境下，每个事务需要在session.close和session.disconnect()被调用 Nonstrict read/write: 这种策略不保障两个同时进行的事务会修改同一块数据，这种策略适用于那些经常读取但是极少更新的数据 Transactional: 这种策略是完全事务化得缓存策略，可以用在JTA环境下 7、hibernate里面的sorted collection 和ordered collection有什么区别sorted collection是在内存中通过Java比较器进行排序的ordered collection是在数据库中通过order by进行排序的 8、Hibernate工作原理？1.读取并解析配置文件2.读取并解析映射信息，创建SessionFactory3.打开Sesssion4.创建事务Transation5.持久化操作6.提交事务7.关闭Session8.关闭SesstionFactory 9、为什么要用Hibernate 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 10、Hibernate是如何延迟加载?当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 11、Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)类与类之间的关系主要体现在表与表之间的关系进行操作，它们都是对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、 12、说下Hibernate的缓存机制内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存 二级缓存：a) 应用及缓存b) 分布式缓存条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据c) 第三方缓存的实现 13、Hibernate的查询方式Sql、Criteria,objectcompositionHql：1、 属性查询2、 参数查询、命名参数查询3、 关联查询4、 分页查询5、 统计函数 14、如何优化Hibernate？1.使用双向一对多关联，不使用单向一对多2.灵活使用单向一对多关联3.不用一对一，用多对一取代4.配置对象缓存，不使用集合缓存5.一对多集合使用Bag,多对多集合使用Set 继承类使用显式多态 表字段要少，表关联不要怕多，有二级缓存撑腰 15、Hibernate有哪几种查询数据的方式3种：hql、条件查询QBC(QueryBy Criteria)、原生sql （通过createSQLQuery建立） 16、谈谈Hibernate中inverse的作用inverse属性默认是false,就是说关系的两端都来维护关系。比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。Gp)i如果Student这边inverse=”true”, 那么关系由另一端Teacher维护，就是说当插入Student时，不会操作TeacherStudent表（中间表）。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false”或默认时，会导致在中间表中插入两次关系。 17、Detached Object（游离对象）有什么好处Detached Object（游离对象）可以传递到任何层直到表现层而不是用任何DTO(DataTransfer Objects). 然后你还可以重新把游离对象赋给另外一个Session. 18、JDBC hibernate 和 ibatis 的区别jdbc:手动手动写sqldelete、insert、update要将对象的值一个一个取出传到sql中,不能直接传入一个对象。select:返回的是一个resultset，要从ResultSet中一行一行、一个字段一个字段的取出，然后封装到一个对象中，不直接返回一个对象。ibatis的特点:半自动化sql要手动写delete、insert、update:直接传入一个对象select:直接返回一个对象hibernate:全自动不写sql,自动封装delete、insert、update:直接传入一个对象select:直接返回一个对象 19、在数据库中条件查询速度很慢的时候,如何优化?1.建索引2.减少表之间的关联3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据量大的表排在前面4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 20、什么是SessionFactory,她是线程安全么？SessionFactory 是Hibrenate单例数据存储和线程安全的，以至于可以多线程同时访问。一个SessionFactory 在启动的时候只能建立一次。SessionFactory应该包装各种单例以至于它能很简单的在一个应用代码中储存. 21、Hibernate的五个核心接口Configuration 接口：配置Hibernate，根据其启动hibernate，创建SessionFactory 对象；SessionFactory 接口：初始化Hibernate，充当数据存储源的代理，创建session 对象，sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级、二级缓存；Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个线程共享同一个session，是轻量级、一级缓存；Transaction 接口：管理事务；Query 和Criteria 接口：执行数据库的查询。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/blog/tags/java/"}]},{"title":"静态代码","slug":"静态代码","date":"2018-05-07T10:09:18.240Z","updated":"2018-05-07T10:47:57.861Z","comments":true,"path":"2018/05/07/静态代码/","link":"","permalink":"http://yoursite.com/blog/2018/05/07/静态代码/","excerpt":"","text":"静态代码父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法； 12345678910111213141516171819202122232425class A&#123; static &#123; System.out.println(\"父类静态代码块\"); &#125; public A()&#123; System.out.println(\"父类构造方法\"); &#125; &#123; System.out.println(\"父类初始化块\"); &#125;&#125;public class B extends A&#123; static&#123; System.out.println(\"子类静态代码块\"); &#125; public B()&#123; System.out.println(\"子类构造方法\"); &#125; &#123; System.out.println(\"子类初始化块\"); &#125; public static void main(String[] args)&#123; new B(); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"解释型语言和编译型语言的区别","date":"2018-05-06T09:43:17.000Z","updated":"2018-05-06T09:43:17.000Z","comments":true,"path":"2018/05/06/解释型语言和编译型语言的区别/","link":"","permalink":"http://yoursite.com/blog/2018/05/06/解释型语言和编译型语言的区别/","excerpt":"","text":"解释型语言和编译型语言的区别首先，我们编程都是用的高级语言(写汇编和机器语言的大牛们除外)，计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序 说到翻译，其实翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统（不仅仅只是通过编译器，编译器只是编译系统的一部分）把高级语言翻译成机器语言（具体翻译过程可以参看下图），把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高，但也不能一概而论，部分解释型语言的解释器通过在运行时动态优化代码，甚至能够使解释型语言的性能超过编译型语言。 一个完整的编译系统与一个用C编写的程序hello.c的编译过程 解释则不同，解释型语言编写的程序不需要编译。解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行的时候才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。 编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/ObjectPascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB等等。 但随着硬件的升级和设计思想的变革，编译型和解释型语言越来越笼统，主要体现在一些新兴的高级语言上，而解释型语言的自身特点也使得编译器厂商愿意花费更多成本来优化解释器，解释型语言性能超过编译型语言也是必然的。 说到这里，我们有必要说一下java与C#。解释型语言和编译型语言的区别JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。而在现实中，java开发工具JDK提供了两个很重要的命令来完成上面的编译和解释（翻译）过程。两个命令分别是java.exe和javac.exe，前者加载java类文件，并逐步对字节码文件进行编译，而另一个命令则对应了java语言的解释(javac.exe)过程。在次序上，java语言是要先进行编译的过程，接着解释执行。 C#语言是编译型语言，但其“编译”过程比较特殊，具体说明如下： C#程序在第一次运行的时候，会依赖其.NETFrameworker平台，编译成IL中间码），然后由JITcompiler翻译成本地的机器码执行。从第二次在运行相同的程序，则不需要再执行以上编译和翻译过程，而是直接运行第一次翻译成的机器码。所以对于C#来说，通常第一次运行时间会很长，但从第二次开始，程序的执行时间会快很多。 那么，C#为什么要进行两次“编译”呢？其实，微软想通过动态编译（由JITcompiler工具实现）来实现其程序运行的最优化。如果代码在运行前进行动态编译运行，那么JITcompiler可以很智能的根据你本地机器的硬件条件来进行优化，比如使用更好的register,机器指令等等，而不是像原来那样，build一份程序针对所有硬件的机器跑，没有充分利用各个机器的条件。 另外，还有我们经常用到的脚本语言，比如JavaScript、Shell等语言都是脚本语言，本质上来说，脚本语言就是解释型语言。","categories":[],"tags":[]},{"title":"HIbernate和Mybatis优缺点对比","slug":"HIbernate和Mybatis优缺点对比","date":"2018-05-05T04:49:17.000Z","updated":"2018-05-07T10:43:22.645Z","comments":true,"path":"2018/05/05/HIbernate和Mybatis优缺点对比/","link":"","permalink":"http://yoursite.com/blog/2018/05/05/HIbernate和Mybatis优缺点对比/","excerpt":"","text":"Hibernate的优点：1、hibernate是全自动，hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。 2、功能强大，数据库无关性好，O/R映射能力强，需要写的代码很少，开发速度很快。 3、有更好的二级缓存机制，可以使用第三方缓存。 4、数据库移植性良好。 5、hibernate拥有完整的日志系统，hibernate日志系统非常健全，涉及广泛，包括sql记录、关系异常、优化警告、缓存提示、脏数据警告等 Hibernate的缺点：1、学习门槛高，精通门槛更高，程序员如何设计O/R映射，在性能和对象模型之间如何取得平衡，以及怎样用好Hibernate方面需要的经验和能力都很强才行 2、hibernate的sql很多都是自动生成的，无法直接维护sql；虽然有hql查询，但功能还是不及sql强大，见到报表等变态需求时，hql查询要虚，也就是说hql查询是有局限的；hibernate虽然也支持原生sql查询，但开发模式上却与orm不同，需要转换思维，因此使用上有些不方便。总之写sql的灵活度上hibernate不及mybatis。 Mybatis的优点：1、易于上手和掌握，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。 2、sql写在xml里，便于统一管理和优化， 解除sql与程序代码的耦合。 3、提供映射标签，支持对象与数据库的orm字段关系映射 4、 提供对象关系映射标签，支持对象关系组建维护 5、提供xml标签，支持编写动态sql。 6、速度相对于Hibernate的速度较快 Mybatis的缺点：1、关联表多时，字段多的时候，sql工作量很大。 2、sql依赖于数据库，导致数据库移植性差。 3、由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。 4、对象关系映射标签和字段映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。 5、DAO层过于简单，对象组装的工作量较大。 6、不支持级联更新、级联删除。 7、Mybatis的日志除了基本记录功能外，其它功能薄弱很多。 8、编写动态sql时,不方便调试，尤其逻辑复杂时。 9、提供的写动态sql的xml标签功能简单，编写动态sql仍然受限，且可读性低。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/blog/tags/数据库/"}]},{"title":"","slug":"友链","date":"2018-05-04T14:21:08.000Z","updated":"2018-05-04T14:21:08.000Z","comments":true,"path":"2018/05/04/友链/","link":"","permalink":"http://yoursite.com/blog/2018/05/04/友链/","excerpt":"","text":"#http://www.kindemh.cn/","categories":[],"tags":[]},{"title":"数据库ACID","slug":"数据库ACID","date":"2018-04-12T01:23:24.786Z","updated":"2018-05-07T10:43:58.622Z","comments":true,"path":"2018/04/12/数据库ACID/","link":"","permalink":"http://yoursite.com/blog/2018/04/12/数据库ACID/","excerpt":"","text":"#码农 1. 原子性编辑 * 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 2. 一致性编辑 * 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。 * 也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性 3. 隔离性编辑 * 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 4. 持久性编辑 * 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 * 由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，要正确实现ACID并不容易。ACID建议数据库将所有需要更新以及修改的资料一次操作完毕，但实际上并不可行。 * 目前主要有两种方式实现ACID：第一种是Write ahead logging，也就是日志式的方式(现代数据库均基于这种方式)。第二种是Shadow paging。 * 相对于WAL（write ahead logging）技术，shadow paging技术实现起来比较简单，消除了写日志记录的开销恢复的速度也快(不需要redo和undo)。shadow paging的缺点就是事务提交时要输出多个块，这使得提交的开销很大，而且以块为单位，很难应用到允许多个事务并发执行的情况——这是它致命的缺点。 * WAL 的中心思想是对数据文件 的修改（它们是表和索引的载体）必须是只能发生在这些修改已经 记录了日志之后 -- 也就是说，在日志记录冲刷到永久存储器之后． 如果我们遵循这个过程，那么我们就不需要在每次事务提交的时候 都把数据页冲刷到磁盘，因为我们知道在出现崩溃的情况下， 我们可以用日志来恢复数据库：任何尚未附加到数据页的记录 都将先从日志记录中重做（这叫向前滚动恢复，也叫做 REDO） 然后那些未提交的事务做的修改将被从数据页中删除 （这叫向后滚动恢复 - UNDO）。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/blog/tags/数据库/"}]},{"title":"java中new的对象怎么被内存回收","slug":"java中new的对象怎么被内存回收","date":"2018-03-27T03:35:58.000Z","updated":"2018-03-27T04:38:26.000Z","comments":true,"path":"2018/03/27/java中new的对象怎么被内存回收/","link":"","permalink":"http://yoursite.com/blog/2018/03/27/java中new的对象怎么被内存回收/","excerpt":"","text":"#码农java,使用new创建对象，并将该对象的引用返回…对象依然存在，不会被垃圾回收,是什么意思啊？“我们在方法内部使用new创建对象，并将该对象的引用返回。如果该返回被一个引用接收，由于对象的引用不为0，对象依然存在，不会被垃圾回收。” 1User u = new User(); 如上面代码，简单说就是new User()的时候，会返回一个地址，并且将地址赋值给引用u，当这个引用被u持有的时候，java会认为这个对象时有用的，不会回收对象，如果你之后执行了好比说： 123u = null;//或u = new User(); 这样的代码，那么这个u就不在持有之前对象的地址了，变成了空或者新的地址，这个时候如果没有其他引用持有了之前对象的地址，之前的对象就没有访问方法了，那么gc(垃圾回收器)运行的时候会认为这个对象没用了，将他从内存中释放掉。 一句话：如果这个对象没有被 任何人 引用 它 ，就会被回收 注意回收的是new 的那个对象， String a ; 与String a = new String ()有什么区别？ 这么形容，String a相当于你说“我想喝水”，但是只是说说，没有水也没有杯子。。。String a = new String()就是说“我想喝水”，并且别人给你了一个杯子。。。String a = “This sucks!”，就是你说“我想喝水”，然后给你一个装满水的杯子 123456String a;//a是一个引用，或者叫别名 a== null;a 没有指向一个对象String a = new String ()a != null;a 指向了一个对象 栈和堆的变化： String a，只是声明了一个变量，存储在”栈”中。。。String a = new String()，不仅在栈中声明了这个变量，同时在“堆”中划分了一片区域（为空），变量存储只想这片区域的地址。。。String a = “This sucks!”，就是把“堆”中填充上”This sucks!”的内容 String source=”abc”; 查找栈中是否存在“abc”的地址，没有，那么新建对象”abc”,这个abc 好像是在静态区 引用变量source指向之String str1=”abc”; 同样子在栈中查找，存在，那么str1指向已经存在的“abc”String str2=new String(“abc”); 在堆中新建对象”abc”,引用str2指向之。 类似于String source=“”这样的对象赋值，不一定创建了一个对象（在已有的栈中查找是否已存在。），而new String（）一定是在堆中新建了一个对象。 String a：定义一个字符串类型的变量名为a的变量String a = new String () ：这句活的作用是创建一个对象String是数据类型，但不是字符串类型，这里指的是引用类型，是一个String类。String ()是构造函数new在堆内存中开辟一个空间，String ()完成构造函数的初始化动作后，把空间的地 址值赋值给a a是一个引用类型，通过a可以引用String类中的成员变量和成员方法，因为a有一个地址指向String类 在函数中定义的一些 基本类型 的变量 和 对象的引用变量 都在 函数 的栈内存 中分配。 栈的内存回收：{ 里面定义变量 }当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 堆内存回收： 堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 java中变量在内存中的分配 1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭 2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存 3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放 实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针！","categories":[],"tags":[]},{"title":"将javaBean对象转化成Map","slug":"将javaBean对象转化成Map","date":"2018-03-25T10:35:00.000Z","updated":"2018-05-07T10:44:11.013Z","comments":true,"path":"2018/03/25/将javaBean对象转化成Map/","link":"","permalink":"http://yoursite.com/blog/2018/03/25/将javaBean对象转化成Map/","excerpt":"","text":"#码农 1234567891011121314151617181920212223242526272829303132package com.dongnengyu.mybatis_test2.service;/** * 董能宇 (dongnengyu@gmail.com) * 2018/3/25 */import org.apache.commons.beanutils.PropertyUtilsBean;import java.beans.PropertyDescriptor;import java.util.HashMap;import java.util.Map;public class JavaBeanUtil &#123; //将javaBean对象转化成Map public Map&lt;String, Object&gt; beanToMap(Object obj) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(0); try &#123; PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean(); PropertyDescriptor[] descriptors = propertyUtilsBean.getPropertyDescriptors(obj); for (int i = 0; i &lt; descriptors.length; i++) &#123; String name = descriptors[i].getName(); if (!\"class\".equals(name)) &#123; params.put(name, propertyUtilsBean.getNestedProperty(obj, name)); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return params; &#125;&#125;","categories":[],"tags":[]},{"title":"java泛型基础--源代码与编译代码对比","slug":"泛型","date":"2018-03-23T07:51:50.000Z","updated":"2018-03-23T08:48:53.000Z","comments":true,"path":"2018/03/23/泛型/","link":"","permalink":"http://yoursite.com/blog/2018/03/23/泛型/","excerpt":"","text":"泛型 #码农 Java泛型基础 泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 &lt;? extends T&gt;和&lt;? super T&gt;的区别&lt;? extends T&gt;表示该通配符所代表的类型是T类型的子类。&lt;? super T&gt;表示该通配符所代表的类型是T类型的父类。 java不可能实现真正的泛型 12345678910111213141516171819202122232425262728293031323334//源代码import com.oracle.tools.packager.Log;import java.util.ArrayList;import java.util.List;public class Main &#123; // 泛型方法 printArray public static &lt; E &gt; void printArray( E[] inputArray ) &#123; // 输出数组元素 for ( E element : inputArray )&#123; System.out.printf( \"%s \", element ); &#125; System.out.println(); &#125; public static void main( String args[] ) &#123; // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = &#123; 1, 2, 3, 4, 5 &#125;; Double[] doubleArray = &#123; 1.1, 2.2, 3.3, 4.4 &#125;; Character[] charArray = &#123; 'H', 'E', 'L', 'L', 'O' &#125;; System.out.println( \"整型数组元素为:\" ); printArray( intArray ); // 传递一个整型数组 System.out.println( \"\\n双精度型数组元素为:\" ); printArray( doubleArray ); // 传递一个双精度型数组 System.out.println( \"\\n字符型数组元素为:\" ); printArray( charArray ); // 传递一个字符型数组 &#125;&#125; 123456789101112131415161718192021222324252627//编译代码public class Main &#123; public static void printArray(Object[] inputArray) &#123; Object[] var1 = inputArray; int var2 = inputArray.length; for(int var3 = 0; var3 &lt; var2; ++var3) &#123; Object element = var1[var3]; System.out.printf(\"%s \", new Object[]&#123;element&#125;); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; Integer[] intArray = new Integer[]&#123;Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4), Integer.valueOf(5)&#125;; Double[] doubleArray = new Double[]&#123;Double.valueOf(1.1D), Double.valueOf(2.2D), Double.valueOf(3.3D), Double.valueOf(4.4D)&#125;; Character[] charArray = new Character[]&#123;Character.valueOf('H'), Character.valueOf('E'), Character.valueOf('L'), Character.valueOf('L'), Character.valueOf('O')&#125;; System.out.println(\"鏁村瀷鏁扮粍鍏冪礌涓�:\"); printArray(intArray); System.out.println(\"\\n鍙岀簿搴﹀瀷鏁扮粍鍏冪礌涓�:\"); printArray(doubleArray); System.out.println(\"\\n瀛楃鍨嬫暟缁勫厓绱犱负:\"); printArray(charArray); &#125;&#125;","categories":[],"tags":[]},{"title":"5个经典多线程问题","slug":"5个经典的同步问题","date":"2018-03-20T14:21:54.000Z","updated":"2018-03-20T14:30:00.000Z","comments":true,"path":"2018/03/20/5个经典的同步问题/","link":"","permalink":"http://yoursite.com/blog/2018/03/20/5个经典的同步问题/","excerpt":"","text":"哲学家就餐 生产者-消费者问题 读者-写者问题 熟睡的理发师问题 三个烟鬼的问题","categories":[],"tags":[]},{"title":"哲学家就餐问题","slug":"哲学家就餐问题","date":"2018-03-20T13:35:51.000Z","updated":"2018-03-20T14:47:48.000Z","comments":true,"path":"2018/03/20/哲学家就餐问题/","link":"","permalink":"http://yoursite.com/blog/2018/03/20/哲学家就餐问题/","excerpt":"","text":"#码农 几种经典解法 资源分级的解法。为资源（也就是筷子）分配一个偏序结构，所有资源都必须按顺序访问，也即拿起筷子必须按照一定的顺序，比如：先拿编号较小的筷子，再拿编号较大的筷子。放下筷子的顺序则无所谓。这种方法可以避免死锁。例如，若每个人都拿起身边的小号的筷子，则五号筷子就没有人拿。这种方法的效率底下。因为对于实际的问题来说，一些计算机程序事先并不知道自己所要求的资源都有哪些。那么，假若它们拿了3、4、5号资源之后，若发现需要拿2号资源，则必须先释放3、4、5号资源，才能拿到2号资源，效率十分低下。 仲裁者解决方案引入一个服务员（仲裁者）。为了拿到筷子，哲学家必须向服务员发送请求。服务员每次只服务一个哲学家，直到他拿起两只筷子为止。服务员可以使用mutex实现，这种方法限制了并行性，也即限制了在筷子允许的情况下，多个哲学家同时吃饭的可能性。若一个哲学家在吃饭，而他的邻座发起了请求，则其他的哲学家必须等到邻座拿到了2只筷子之后才能吃饭，即便他们面前的筷子是空闲的。 每个哲学家必须确定自己左右手的筷子都可用的时候，才能同时拿起两只筷子进餐，吃完之后同时放下两只筷子 Chandy/Misra方法完全的分布式的方法，不需要仲裁者，但是需要哲学家之间进行一些交流，其描述如下。(1) 首先，给哲学家编号。(2) 若两个哲学家竞争同一个筷子的时候，把筷子给编号比较小的人。(3) 筷子有两个状态，净的和脏的。初始状态下，所有的筷子都是脏的。(4) 哲学家要吃饭时必须拿起两只筷子，当他缺乏某只筷子的时候，发起请求。(5) 若拿着筷子的哲学家受到了请求，如果筷子是干净的，则他不放下筷子；若是脏的，则放下筷子，并且在放下之前，把筷子擦干净。(6) 哲学家吃完的时候，筷子变脏，当他有邻座请求筷子的时候，擦干净筷子，然后给邻座。 这种方法可以解决大规模的并发问题，也能避免饿死问题。但是，不能完全避免死锁现象（当每个哲学家拿到一只干净筷子的时候，则陷入了死锁）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * xiaomu (dongnengyu@gmail.com) * 2018/3/20 *///////////////////////////哲学家类public class Philosopher extends Thread &#123; private String name; private Fork fork; public Philosopher(String name , Fork fork)&#123; super(name); this.fork=fork; this.name=name; &#125; public void run()&#123; while (true)&#123; try &#123; System.out.println(name + \" is thinking \"); sleep((int)(Math.random()*2000));//模拟思考时间 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; fork.takeFork(); try &#123; System.out.println(name + \" is eating \"); sleep((int)(Math.random()*2000));//模拟吃饭时间 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; fork.putFork(); &#125; &#125;&#125;//////////////////////////叉子类class Fork&#123; //五只叉子,初始状态为false，表示放在桌子上 private boolean[] used = &#123;false,false,false,false,false&#125;; /*只有当左右手的筷子都未被使用时，才允许获取筷子，且必须同时获取左右手筷子*/ public synchronized void takeFork()&#123; String name = Thread.currentThread().getName(); int i = Integer.parseInt(name); while (used[i] || used[(i+1)%5])&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; used[i] = true; used[(i+1)%5] = true; notifyAll(); &#125; /*必须同时释放左右手的筷子*/ public synchronized void putFork()&#123; String name = Thread.currentThread().getName(); int i = Integer.parseInt(name); used[i]=false; used[(i+1)%5] = false; notifyAll(); &#125;&#125;//////////////////////////测试类class Test&#123; public static void main(String[] args) &#123; Fork fork =new Fork(); new Philosopher(\"0\" , fork).start(); new Philosopher(\"1\" , fork).start(); new Philosopher(\"2\" , fork).start(); new Philosopher(\"3\" , fork).start(); new Philosopher(\"4\" , fork).start(); &#125;&#125;","categories":[],"tags":[{"name":"码农","slug":"码农","permalink":"http://yoursite.com/blog/tags/码农/"}]},{"title":"多个线程访问共享对象和数据的方式","slug":"多个线程访问共享对象和数据的方式","date":"2018-03-19T14:19:03.000Z","updated":"2018-03-22T07:07:56.000Z","comments":true,"path":"2018/03/19/多个线程访问共享对象和数据的方式/","link":"","permalink":"http://yoursite.com/blog/2018/03/19/多个线程访问共享对象和数据的方式/","excerpt":"","text":"#码农 如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如买票系统 如果每个线程执行的代码不同，这时候就需要不同的Runnable对象那个，有如下两种方式实现这些Runnable对象之间的数据共享 将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样就容易实现针对该数据进行的各个操作的互斥和通信； 将这些Runnable对象作为其中一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配到外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象那个调用外部类的这些方法","categories":[],"tags":[]},{"title":"一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z。","slug":"一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z","date":"2018-03-19T09:53:31.000Z","updated":"2018-03-19T10:19:41.000Z","comments":true,"path":"2018/03/19/一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z/","link":"","permalink":"http://yoursite.com/blog/2018/03/19/一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z/","excerpt":"","text":"#码农12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package numberTurnToCharacter;/** * xiaomu (dongnengyu@gmail.com) * 2018/3/19 * 一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z。 解决的方法有很多种，比如： 使用synchronized, wait和notifyAll 使用Lock 和 Condition 使用Semaphore 等。 本文采用synchronized, wait和notifyAll */public class Thread1 &#123; public static void main(String[] args) &#123; Print print = new Print(); new Thread(new Runnable() &#123; @Override public void run() &#123; print.printNum(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; print.printChar(); &#125; &#125;).start(); &#125;&#125;class Print &#123; private boolean b = true; public synchronized void printNum() &#123; for (int i = 1; i &lt;= 52; i++) &#123; System.out.println(i); if (i % 2 == 0) &#123; try &#123; this.notifyAll(); this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if(i == 52)&#123; this.notifyAll(); &#125; &#125; &#125; public synchronized void printChar() &#123; for (char c = 'A'; c &lt;= 'Z'; c++) &#123; System.out.println(c); try &#123; this.notifyAll(); this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Collections使用","slug":"Collections使用","date":"2018-03-18T11:28:09.000Z","updated":"2018-03-19T10:20:50.000Z","comments":true,"path":"2018/03/18/Collections使用/","link":"","permalink":"http://yoursite.com/blog/2018/03/18/Collections使用/","excerpt":"","text":"#码农 util.Collection与java.util.Collections区别 util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * xiaomu (dongnengyu@gmail.com) * 2018/3/18 */import java.util.Arrays;import java.util.Collections;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; intList = Arrays.asList(33, 24, 18, 6, 9, 99); //查找最小值 System.out.println(Collections.min(intList)); // 查找最大值 System.out.println(Collections.max(intList)); //使集合乱序 Collections.shuffle(intList); System.out.println(intList); //该方法用于返回一个不可变列表组成的n个拷贝的指定对象。 // 生成一个由10个100组成的整数列表 List&lt;Integer&gt; nCopiesList = Collections.nCopies(10, 100); //[100, 100, 100, 100, 100, 100, 100, 100, 100, 100] System.out.println(nCopiesList); //对集合排序，从小到大 Collections.sort(intList); System.out.println(intList); //对集合排序，从大到小，需要重写，以后再填坑 Collections.sort(intList); System.out.println(intList); //binarySearch System.out.println(Collections.binarySearch(intList, 18)); //copy //用两个参数，一个目标 List 和一个源 List, 将源的元素拷贝到目标，并覆盖它的内容。目标 List至少与源一样长。 List&lt;String&gt; listOne = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); List&lt;String&gt; listTwo = Arrays.asList(\"X\", \"Y\", \"Z\"); //listOne 是目标List,所以他的元素会被listTwo（源List）覆盖 Collections.copy(listOne, listTwo); System.out.println(listOne);// [X, Y, Z, D] System.out.println(listTwo);//[X, Y, Z] //disJoint //用于检查两个集合有无相同的元素，如果没有则返回true。 List&lt;String&gt; list3 = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); List&lt;String&gt; list4 = Arrays.asList(\"A\", \"Y\", \"Z\"); boolean disJoint = Collections.disjoint(list3, list4); // 返回false，因为两个集合都有A System.out.println(disJoint); //未完待续 &#125;&#125;","categories":[],"tags":[]},{"title":"java多线程","slug":"java多线程","date":"2018-03-17T02:26:36.000Z","updated":"2018-05-07T13:24:17.214Z","comments":true,"path":"2018/03/17/java多线程/","link":"","permalink":"http://yoursite.com/blog/2018/03/17/java多线程/","excerpt":"","text":"#码农 创建一个线程 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过实现 Runnable 接口来创建线程创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：public void run()你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。Thread 定义了几个构造方法，下面的这个是我们经常使用的：Thread(Runnable threadOb,String threadName);这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。新线程创建之后，你调用它的 start() 方法它才会运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class RunnableDemo implements Runnable &#123; private Thread t; private String threadName; RunnableDemo( String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName ); &#125; public void run() &#123; System.out.println(\"Running \" + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(\"Thread \" + threadName + \" interrupted.\"); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; public void start () &#123; System.out.println(\"Starting \" + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; RunnableDemo R1 = new RunnableDemo( \"Thread-1\"); R1.start(); RunnableDemo R2 = new RunnableDemo( \"Thread-2\"); R2.start(); &#125; &#125;编译以上程序运行结果如下：Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 通过继承Thread来创建线程123456789101112131415161718192021222324252627282930313233343536373839404142\u0003class ThreadDemo extends Thread &#123; private Thread t; private String threadName; ThreadDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;); T1.start(); ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;); T2.start(); &#125; &#125;","categories":[],"tags":[]},{"title":"blog小工具","slug":"blog小工具","date":"2018-03-16T05:03:46.000Z","updated":"2018-03-16T05:05:00.000Z","comments":true,"path":"2018/03/16/blog小工具/","link":"","permalink":"http://yoursite.com/blog/2018/03/16/blog小工具/","excerpt":"","text":"#码农图片转base64","categories":[],"tags":[]},{"title":"ajaxForm 使用","slug":"ajaxForm","date":"2018-03-16T03:41:49.000Z","updated":"2018-03-19T12:34:45.000Z","comments":true,"path":"2018/03/16/ajaxForm/","link":"","permalink":"http://yoursite.com/blog/2018/03/16/ajaxForm/","excerpt":"","text":"#码农 面临问题：form表单submit之后，后端会返回提示信息。但原生html无法获取后端返回的数据，就造成了这样一种局面：提交之后，页面发生跳转，在一个空白页面上显示了后端返回的json数据，用户体验0分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jQuery Form插件例子-ajaxForm()&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/&gt; &lt;script src=\"js/jquery-3.3.1.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"js/jquery.form.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; $('#myForm').ajaxForm(function () &#123; var json = &#123;&#125;; json.account = document.getElementById(\"account\").value; json.password = document.getElementById(\"password\").value; $.ajax(&#123; async: false, url: \"/login\", data: JSON.stringify(json), method: \"post\", contentType: 'application/json;charset=UTF-8', //返回数据 dataType: \"json\", success: function (data) &#123; // alert(JSON.stringify(data)); var data2 = eval(data); var data3 = JSON.stringify(data); // alert(data2.login); if (data2.login == \"登录成功\") &#123; $('#output1').html(\"登录成功\").show(); &#125; else if (data2.login == \"账号不存在\")&#123; $('#output1').html(\"账号不存在\").show(); &#125; else &#123; $('#output1').html(\"密码错误\").show(); &#125; &#125;, error: function (data) &#123; //失败的话 alert(\"fail\"); &#125;, &#125;); &#125; ) &#125; ) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt; Demo 1 : form插件的使用--ajaxForm(). &lt;/h3&gt;&lt;form id=\"myForm\" method=\"get\"&gt; 账号&lt;input type=\"text\" id=\"account\" value=\"\"&gt; &lt;/br&gt; 密码&lt;input type=\"password\" id=\"password\" value=\"\"&gt; &lt;/br&gt; &lt;input type=\"submit\" id=\"test\" value=\"提交\"/&gt; &lt;br/&gt; &lt;div id=\"output1\" style=\"display:none;\"&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"数据库错误：Parameter index out of range (1 > number of parameters, which is 0).","slug":"数据库错误：Parameter index out of range (1 > number of parameters, which is 0)","date":"2018-02-27T13:49:11.000Z","updated":"2018-02-27T13:52:03.000Z","comments":true,"path":"2018/02/27/数据库错误：Parameter index out of range (1 > number of parameters, which is 0)/","link":"","permalink":"http://yoursite.com/blog/2018/02/27/数据库错误：Parameter index out of range (1 > number of parameters, which is 0)/","excerpt":"","text":"错误发生原因其实很简单😏，就是当设置参数时，没有相应的问号与之匹配（或者根本就没有？号）.如果是：Parameter index out of range (26 &gt; number of parameters, which is 25).翻译为：找到了25个问号，却插入了26个值，导致参数越界（根据得到的信息打印将很容易判断数据是否与数据库字段匹配等小问题）。 与sql语句有关的原因如下：1.？号被单引号包围。（如setString(1,”slkdjfkd”);时sql语句为：insert into table1 (c1,c2) values (‘?’,’?’)）。此时？会被作为参数传入，而不会再传入 setString里面的值。 2.sql语句中没有？号，在后面用到了set语句。（如：select * from table）；此时无需传值。传值就会出错。 3.初学者很常见的错误：?—？这两个问号是不同了，因为一个是中文，一个是英文，如果在sql语句中写入的是英文，将无法识别。 其他原因：1.连接已经关闭。 如果与其他操作语句一起公用conn时，如果上一操作已经关闭连接，则会报错。表现为：时而能够进行操作，时而不能。2.pstm没有初始化，无驱动包，得到连接出错等基础问题……","categories":[],"tags":[]},{"title":"Java字符串拼接","slug":"Java字符串拼接","date":"2018-02-26T11:37:05.000Z","updated":"2018-02-26T11:42:10.000Z","comments":true,"path":"2018/02/26/Java字符串拼接/","link":"","permalink":"http://yoursite.com/blog/2018/02/26/Java字符串拼接/","excerpt":"","text":"plus方式 当左右两个量其中有一个为String类型时，用plus方式可将两个量转成字符串并拼接。 String a=&quot;&quot;;int b=0xb;String c=a+b; concat方式 当两个量都为String类型且值不为null时，可以用concat方式。 String a=&quot;a&quot;;String b=&quot;b&quot;;String c= a.concat(b); 理论上，此时拼接效率应该最高，因为已经假定两个量都为字符串，做底层优化不需要额外判断或转换，而其他方式无论如何优化，都要先走到这一步。 append方式 当需要拼接至少三个量的时候，可以考虑使用StringBuffer#append()以避免临时字符串的产生 StringBuffer buf=new StringBuffer()buf.append(&quot;a&quot;);if(someCondition){buf.append(&quot;b&quot;);}buf.append(&quot;c&quot;);String d=buf.toString(); 当a,b,c拼接起来会很长时，可以给在构造器中传入一个合适的预估容量以减少因扩展缓冲空间而带来的性能开销。 StringBuffer buf=new StringBuffer(a.length()+b.length()+c.length()); JDK对外提供的一些涉及可append CharSequence的参数或返回值类型往往是StringBuffer类型，毕竟安全第一，而StringBuffer大多数情况(包括append操作)线程安全。 若不会出现多线程同时对一实例并发进行append操作，建议使用非线程安全的StringBuilder以获得更好性能 其他 若需拼接至少三个量，只用一个连续拼接的语句就可完成时，从使代码简洁角度考虑，用plus方式。 String a=&quot;a&quot;;String b=&quot;b&quot;;String c=&quot;c&quot;;String d=a+b+c; 此时，第4句经JDK编译后其字节码(或)会自动优化为等效于下列代码编译后的字节码。 String d=new StringBuilder().append(a).append(b).append(c).toString(); 若采用模板+参数来替换占位符的方式或需同时对要拼接日期/数字进行格式化，可以用String.format()来实现 String c=String.format(&quot;a %s!&quot;,&quot;b&quot;); 此方式资源占用/耗时相对会稍多，毕竟首先要解析模板。当用方法封装并进行format条件调用时，整体效率也不算差。","categories":[],"tags":[]},{"title":"MarkDown文档插入图片","slug":"MarkDown文档插入图片","date":"2018-02-24T08:06:51.000Z","updated":"2018-02-24T08:40:52.000Z","comments":true,"path":"2018/02/24/MarkDown文档插入图片/","link":"","permalink":"http://yoursite.com/blog/2018/02/24/MarkDown文档插入图片/","excerpt":"","text":"将图片嵌入Markdown文档中一直是一个比较麻烦的事情。通常的做法是将图片存入本地某个路径或者网络存储空间，使用URL链接的形式插入图片： ![image][url_to_image] 这样做一个明显的麻烦之处在于处理图片与Markdown文档的一致性上。如果我们要拷贝文档，或者图片遭到误删/云端链接失效，就会变得不便。最让我们省心的方法便是将图片直接放到文档内部。 一个将图片嵌入文档中的方法是使用base64编码。步骤比较简单： 将图片或截图保存在本地； 使用在线工具将图片转码至base64编码；(link1, link2)； 在文档中插入编码： 1![image][data:image/png;base64, ......] 当然base64编码一般很长，直接将编码放入段落内部会影响正常编辑。通常的做法是将base64编码定义到一个中间变量中，将编码本体放到文档末： 1234![image][tmp]your document here ...[tmp]:data:image/png;base64, ...... 使用该技巧的时候需要注意，并不是所有的Markdown编辑器都支持这种方法。而且一些Markdown编辑器只支持特定的图片格式。如有道云笔记只支持png格式的图片编码。需要在保存图片文件的时候加以注意。","categories":[],"tags":[]},{"title":"base64测试","slug":"base64测试","date":"2018-02-24T07:29:02.000Z","updated":"2018-02-24T07:58:43.000Z","comments":true,"path":"2018/02/24/base64测试/","link":"","permalink":"http://yoursite.com/blog/2018/02/24/base64测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"舌尖上的中国3影评","slug":"舌尖上的中国3影评","date":"2018-02-24T06:57:07.000Z","updated":"2018-02-24T07:49:05.000Z","comments":true,"path":"2018/02/24/舌尖上的中国3影评/","link":"","permalink":"http://yoursite.com/blog/2018/02/24/舌尖上的中国3影评/","excerpt":"","text":"把糟粕当做文化。把落后当做质朴。把迷信当做传统。把反智当做精华。几年前舌尖第一部横空出世，看完我会觉得“中国好吃的可真多”。再后来出了舌尖二，让我觉得“没用的废话可真多”。这部舌尖三看完几集，顿时觉得“中国落后的地方可真多”。全篇都是在宣扬愚昧和落后的生产方式，加之玄之又玄的忽悠，仿佛有一种传销的即视感。就好像某“导师”在台上给学员们介绍手中产品：“我这个锅，底是圆的，铲子是方的，体现了天圆地方的道家真理！前后两个把手，象征稳抓经济两手都要硬！滴两滴油，放一瓣蒜，象征2学1做的方针！我这个锅每个铁分子（经大家提醒应该是铁原子，化学知识都还给老师了……）都饱含大自然的气息，并且与宇宙引力波形成共振，吸收日月精华！用这口锅炒菜，不仅补铁补气补查克拉，背着锅出去旅行还能延年益寿！”大大前年笑话完台湾用爱发电，大前年我们笑话完朴槿惠信邪教，前年笑话完雷雷太极大师，去年笑话完日本的大忽悠煮饭仙人，今年我们又紧紧跟随反智的脚步，果然是【自古出神棍，东亚尤其多】 作者：湿身人面酱链接：https://www.zhihu.com/question/63393032/answer/324965613来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 有一个令人警惕的地方，节目里宣称西安回坊自唐朝就开始形成了。可实际上那时候根本没有什么回民。在舌尖上的中国这种美食类节目里，这个说法也许只是一个小错误。但是联系现在国内蔓延开来的泛清真化，更兼清真盐清真牛奶等等早已悄无声息地改变了很多人的生活，宗教势力抬头已无法遏制。傅统先《中国回教史》、金吉堂《中国回教史研究》、马以愚《中国回教史鉴》、邱树森《中国回族史》这些穆斯林已经开始明目张胆地篡改历史，如将一系列出身汉族的历史人物如朱元璋海瑞，划归于回族，如将回族马步芳等人一一洗白。一场有预谋的布局早就开始了。2018年央视狗年春晚，公然将尚存争议的涉及穆斯林地图宣布为丝路山水图，更是罔顾事实，直接指鹿为马喊出终点为伊斯兰圣地麦加。莫非不知正是伊斯兰毁灭了途径丝绸之路的那些中亚小国？（24日更新，此画原名涉疑，内容也涉疑，改之）文化渗透恐怖至斯！那么，这个又一次在央视播出的，堂而皇之地将回民历史往前推了一千年的说法，日后真的只是一个小错误么？ 作者：晏公子链接：https://www.zhihu.com/question/63393032/answer/323960751来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 #blog","categories":[],"tags":[]},{"title":"2017年总结","slug":"个人总结/2017年度总结","date":"2018-01-09T16:00:00.000Z","updated":"2018-05-11T06:26:09.535Z","comments":true,"path":"2018/01/10/个人总结/2017年度总结/","link":"","permalink":"http://yoursite.com/blog/2018/01/10/个人总结/2017年度总结/","excerpt":"","text":"2017年总结Linux服务器篇- [x] 租服务器（vps） - [x] 了解vps运作原理（XEN、OpenVZ、KVM、Hyper-V、HVM等） - [x] ssh终端命令操作、如文件管理、vim工具 - [x] 熟悉VIM - [x] 在终端中使用包管理工具安装并配置软件 - [x] 在终端中编译软件源代码方式安装并配置 - [x] 学会部署调试Tomcat、MySQL、Apache等服务器必备软件 - [x] 在vps上使用已有的框架（wordpress、typecho、GitHubPage）搭建博客 - [x] 使用Tomcat、httpd分别部署项目（完全使用自己的前端加后端代码实现简陋的blog）并能尝试解决各种秘制bug - [x] 部署搭建卖翻墙服务的网站、但由于政策原因并不敢开放注册售卖账号（关门大吉） linux深入学习篇（深坑）- [x] linux内核编译（《操作系统原理》） - [x] shell - [ ] 深坑2018继续中。。。。。。 openwrt路由器操作系统深入学习（荒废学业、已弃坑）- [x] 在家用路由器中通过硬改方式刷入openwrt操作系统 - [x] 能编译自己写的代码（hello world）到路由器上运行 - [x] 部署Mysql、python、Apache等常用软件到路由器中并将其改造成一个玩具（无聊） - [x] 网络负载均衡调试 基础学习篇Python- [ ] 大一学的，妈蛋几乎忘了😭 java web- [x] javaSE - [x] HTML - [x] CSS和JavaScript的初步认识 - [x] XML语法和应用 - [x] bootstrap框架学习中 - [x] servlet - [x] jsp - [x] MySQL - [ ] MySQL的JDBC（尚待学习） - [x] Tomcat初步学习 软件工程- [x] 好像没啥好总结的😹 展望未来篇- [ ] 三大框架熟练运用 - [ ] 算法深坑 - [ ] 数据结构重新学习 - [ ] 复习python.爬虫学习 - [ ] 暂时想不到啥了，想到再补✍️","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/blog/tags/总结/"}]},{"title":"sourcing与purchasing的区别","slug":"sourcing与purchasing的区别","date":"2017-12-02T17:32:17.000Z","updated":"2018-03-06T02:07:19.000Z","comments":true,"path":"2017/12/03/sourcing与purchasing的区别/","link":"","permalink":"http://yoursite.com/blog/2017/12/03/sourcing与purchasing的区别/","excerpt":"","text":"#供应链 导读：相对而言，Sourcing的过程可能很短，也可能很长，但确是“一次性行为”，一旦选定合适的供应商并把他们带上正规，Sourcing的任务就基本完成。当然Sourcing的过程可能很长。然后是Purchasing去执行日常订单管理。当然如果Sourcing选定的供应商有表现问题，例如质量、交货、价格等，那么Sourcing有可能再度涉入，寻找新的供应商。当然这种区分有点理论化。在很多公司，Sourcing和Purchasing是由同一组人员完成。但对于建制完全的大公司，总体趋势是把Sourcing从Purchasing分离出来。 定义上的区别与采购有关的词有：Buyer，Purchasing，Procurement和Sourcing。我把它们分别译为：买；采购；获取（或资源获取）；寻源与货源组织。从他们出现的顺序上也可以看出它们虽然最终都完成了采购的业务，但含义和执行工程是不同的： 1．Buyer只是简单的买，完成了“买”的动作和买入了某样物资或服务，侧重于下单，并跟踪订单； 2．Purchasing则有采购的意思，即先要采，然后再买进； 3．Procurement是实现了资源获取，有整合与更好的获得资源的意思； 4．Sourcing一般是制造型企业用的，要求有很强的理工知识和商业感觉，是要去在全球范围内找到最好的资源、然后将找到的货源和资源组合在一起来更好地加以利用，侧重于物料和供应商的开发，开发完成后交给buyer下单跟踪。它们的演变是随着采购业务不断发展的需求而出现和扩展而来的。 职能上的区别和具体分工 Sourcing与Purchasing 翻译成中文， Sourcing，Purchasing和buyer都是采购的意思，但实际上他们的职能是大不相同。 Sourcing是根据客户的需求，寻找，发现，评估，审核，发展合格的供应商，有的叫procurement，意思是发现采购。一般对应中文是供应商开发或发展多。同时也包括新BOM（Bill of Material）报价和谈价的工作。侧重于技术层面，是去寻找和确定符合资质的新供应商或新产品的供应商。偏重于对整体项目的分析。比如你需要采购产品A，你要对A 进行风险分析，比如这个项目是否适合中国的市场，他的技术参数是否是大部分供应商能达到；近期的原油价格会不会涨价，造成运费增加，或者塑料涨价格，你做这个项目有多少saving ；如果有些状况你开始就预料到的并不利于这样项目，你有权将项目停掉，以免浪费人力物力，Sourcing 的这个工作和职位,对潜在风险的预测是有比较高的要求，同时他还可能负责初期的供应商寻找和筛选。 Purchasing是根据sourcing的合格供应商名录，结合生产和销售需求，在合适的时间采购合适的数量的产品。对应中文叫采购的多。是sourcing engineer分析了整个项目风险后决定开始做这个项目后，Purchaser 是项目的执行者，就是去像供应商进行谈价格比价格，确定具体供应商，跟单确认交货期，和工厂协调，邮寄样品，Purchaser 是事物的具体执行者， 你拿到的这些Potential suppliers list 时，供应商的情况要及时和Sourcing engineer 交流。他比较权威，基本上凭借他的经验是一眼可以看出在这个行业中哪些供应商很有能力，哪些不太好。所以说，Sourcing 是比较高级的，他把握了一个项目的整体方向；Purchase 是在正确方向的情况下做一个项目的实施者，主要执行具体的日常采购任务。相对于Sourcing，Purchasing更侧重于订单处理（PO Transaction），即询价、下订单、跟踪订单、催单、收货、付款等。现在因为大量的使用ERP等IT资源，许多大公司的从事 Purchasing的buyer同时也是Planner，即计划人员同时也是采购人员，他们会根据系统的相应信息来发行订单。有一些日资企业因为分工相当细，Planner不会发行订单与供应商联系，还是由BUYER在做订单工作。 相对而言，Sourcing的过程可能很短，也可能很长，但确是“一次性行为”，一旦选定合适的供应商并把他们带上正规，Sourcing的任务就基本完成。当然Sourcing的过程可能很长。然后是Purchasing去执行日常订单管理。当然如果Sourcing选定的供应商有表现问题，例如质量、交货、价格等，那么Sourcing有可能再度涉入，寻找新的供应商。当然这种区分有点理论化。在很多公司，Sourcing和Purchasing是由同一组人员完成。但对于建制完全的大公司，总体趋势是把Sourcing从Purchasing分离出来。 从上面的分工不难看出，Sourcing相对更战略一些，有可持续性，需长期规划；而Purchasing更侧重于日常工作。可以是单独一次商务购买行为。在实际工作中，Sourcing与产品部、工程技术人员等交流较多，而Purchasing则主要是支持生产部、客户服务部（例如备件、配件）。Sourcing team一般由Sourcing Manager加采购/供应商工程师构成；而Purchasing则由Purchasing Manager加采购员、催货员、检验员等组成。 就现阶段的大趋势来看，采购部门的职能逐渐从Purchasing向Sourcing过渡，就是采购的作用和在公司的地位不断提升的过程。采购部门也从原来的订单处理更多参与到战略决策过程，例如决定公司自己制造还是采购（Make or Buy）、选择合适的战略性合作供应商、很大程度上决定产品的最终价格（因为采购部分占的分量越来越大）。当然，对个人而言，如果想向Sourcing方面发展的话，Purchasing的功底还是很有好处。因为那些日常工作也挺能锻炼人的基本功。 采购工作最核心的权力有三个：supplier selection（供应商样品认证）, allocation（采购量分配）和cost down（成本降低）。看一个采购的重要性和工作含金量，我们就看他可以控制住三个权力中的哪些部分。Sourcing肯定可以掌握supplier selection，负责供应商出样，完成样品认证，在系统中建立合格供应商的代码。 Buyer 就是买手、代理之类的，一般更贴近Purchasing，但服装业，或奢侈品行业的sourcing叫buyer或merchandiser的多，但对应中文是买手，而不单是采购。 Sourcing工作职责： (1)供应商开发(或者参与产品开发，具备专业能力） (2)核定采购订单分配比率 (3)主导新供货商的评鉴 (4)主导合格供货商绩效评估与管理 (5)竞标、议价、合约签订与管理 (6)采购单价/标准单价建立与维护厂商报价单(包括单价、材料Lead Time、最小订购量、单位包装)之制订与发行单价记录单(Cost Pattern)之发行与归档 (7)采购单价及付款条件变动时之系统及时维护 (8)异常付款确认与会签 (9)协助工厂必要之材料(或材损)状况处理 (10)总公司采购开发员协助开立L/C作业 (11)e-Supply 导入之前期作业, 并依循供货商管理办法 Buyer工作职责: (1)P/R作业：材料请购书制作 (2)P/O作业：采购订单制作、发行、归档 (3)材料交期确认、控制与跟催 (4)参与新供货商评鉴及合格供货商绩效评估及回馈供货商日常现。 (5)材料入库、退库处理 (6)MDR跟踪与归档。 (7)月结对帐、Invoice传递及付款申请单 8)材损过高时之供货商扣款 (9)执行与导入e-Supply, 并依循供货商管理办法 不同行业的不同定位 在大多数体制不完全的公司里，Sourcing和Purchasing是由同一组人员完成。但对于建制完全的大公司，或者是将Sourcing从Purchasing分离出来、成为两个独立的部门，或者是并在一起、成为Commodity经理的统筹管理范围。一般这两个职能不会并在同一部门。如果是规模很大的公司或一个公司很高层的级别上。应该并在一起,成为Commodity经理的统筹管理范围。但如果是不太大的公司或级别不高的地方，一般也没有Commodity经理，Sourcing会被放到技术部门去。 不同公司，对这些职位的定义可能不同。有的公司Commodity Manager可能负责的是一类产品的采购战略，例如大的供应商选择方向，签订合同，供应商总体绩效等。Purchasing Manager负责日常订单有关的任务，管理Buyer或Procurement Agent。还有一个Materials Manager，该职位的职责从字眼上看更广泛，负责与材料有关的所有任务，例如规划（要买多少，什么时候买）、采购（围绕订单）、库存管理、仓储、物流等。 公司小了，Commodity Manager、Purchasing Manager、Materials Manager很可能就是一个人。在有些公司、行业，这些职位之间的界限有时挺模糊。有些公司，sourcing不能掌握allocation（采购量分配）和cost down（成本降低），这个时候，sourcing的地位就非常尴尬，工作很不好展开，最后很容易变成他们就是到处求人打样，而供应商爱理不理，因为打样要耗费供应商成本，但是后来有不有订单下来，成交价格是多少，sourcing又不能控制，这时，做purchasing的buyer就非常关键，实际作用就大于sourcing。 如果三个权力都集中在sourcing那里，buyer就等于被架空、无事可做，sourcing工作的好坏将会很大程度上影响采购部门的绩效。可是，很多公司并没有把这三项权力集中到采购部，而是被公司更高层的领导所控制。这时，采购部的重要性就大大削弱，甚至退居次席，在选择供应商和谈价格时，都是走过场，停留在表面。至于企业是否以最好的价格买到物料，采购部根本就回答不了。我看过一些大公司的采购记录，他们虽然采用最先进的系统和管理手段，但是他们的采购价格并不好，有些时候非常糟糕，原因就是采购和供应管理中，形式大于实质，采购部没有被赋予足够的权力，没有得到足够的支持，开展工作中有太多的掣肘。 purchasing每个公司可能不一样。sourcing的关键是你是否有决定使用哪个供应商的权利。有些公司的架构是这样： 1.regional purchasing manager-他们制定相应产品的regional strategy, 决定使用那些供应商 2.plant purchasing manager-他们协调SCM（Supply Chain Management）和regional purchasing manager 的关系，同时负责小料的采购 regional purchasing manager的职责： Spending analysis Regular price negotiation Regional strategy setup Saving project initiate Price development control Coordinate global-regional strategy 所以说实权在regional purchasing，实际上就是我们说的sourcing。最基本的一条规则是：谈价格、决定供应商的人绝对不能下单，下单的人绝对不能谈价格。避免道德风险。","categories":[],"tags":[]}]}