{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"dongnengyu","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-02-24T07:03:04.314Z","updated":"2018-02-24T07:03:04.314Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"董能宇联系方式：dongnengyu@gmail.com"},{"title":"关于","date":"2018-02-24T07:18:31.547Z","updated":"2018-02-24T07:03:04.314Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"董能宇联系方式：dongnengyu@gmail.com"},{"title":"","date":"2018-03-17T02:45:28.217Z","updated":"2018-03-17T02:31:16.364Z","comments":true,"path":"docs/15212538763553.html","permalink":"http://yoursite.com/docs/15212538763553.html","excerpt":"Markdown 语法和 MWeb 写作使用说明Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。","text":"Markdown 语法和 MWeb 写作使用说明Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二 * 项目二的子项目一 无序列表 `TAB + * + 空格键` * 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三 1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键` 2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 列表中嵌入代码块语法1. 项目一 有序列表 `数字 + . + 空格键` 列表中嵌入代码块必须前后空一行，如这个写法 12345function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 其他文本。 2. 项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如为 ![GitHub-w140](set-up-git.gif)： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： ~~删除这些~~ 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： *** ***** - - - 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC]"},{"title":"","date":"2018-03-17T02:39:50.118Z","updated":"2018-03-17T02:36:38.384Z","comments":true,"path":"docs/15212538763554.html","permalink":"http://yoursite.com/docs/15212538763554.html","excerpt":"","text":"欢迎使用 MWeb首先介绍一下 MWeb 是什么，MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件。MWeb 使用的是 Github Flavored Markdown 语法，在使用 MWeb 前，建议你一定要去 MWeb 官网首页 看一下介绍视频，MWeb 官网也做了比较详细的帮助，建议你也看一下大概内容，帮助的网址为：http://zh.mweb.im/help.html。 需要您重点注意的MWeb 是有两种模式的：外部模式和文档库模式。MWeb 为了满足所有 Markdown 使用需求，设计了两种模式！外部模式用于打开和编辑所有本地 Markdown 文档。另外为了方便用 Markdown 记笔记，MWeb 设计了文档库模式，文档库中的文档也支持一键生成静态博客，以便于分享。关于两个模式的情况，还是建议您去看一下官网的视频和帮助。 帮助我们改进 MWeb如果你喜欢 MWeb，想让它变得更好，你可以： 推荐 MWeb，让更多的人知道。 给我们发反馈和建议：&#x63;&#111;&#x64;&#101;&#x72;&#x66;&#111;&#x72;&#x61;&#x72;&#x74;&#x2b;&#50;&#51;&#51;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d; 在 Mac App Store 上评价 （如果是在 MAS 上购买的话）。"}],"posts":[{"title":"一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z。","slug":"一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z","date":"2018-03-19T09:53:31.853Z","updated":"2018-03-19T10:19:41.682Z","comments":true,"path":"2018/03/19/一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z/","link":"","permalink":"http://yoursite.com/2018/03/19/一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z/","excerpt":"","text":"#码农12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package numberTurnToCharacter;/** * xiaomu (dongnengyu@gmail.com) * 2018/3/19 * 一个线程打印 1~52,另一个线程打印字母A-Z。打印顺序为12A34B56C……5152Z。 解决的方法有很多种，比如： 使用synchronized, wait和notifyAll 使用Lock 和 Condition 使用Semaphore 等。 本文采用synchronized, wait和notifyAll */public class Thread1 &#123; public static void main(String[] args) &#123; Print print = new Print(); new Thread(new Runnable() &#123; @Override public void run() &#123; print.printNum(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; print.printChar(); &#125; &#125;).start(); &#125;&#125;class Print &#123; private boolean b = true; public synchronized void printNum() &#123; for (int i = 1; i &lt;= 52; i++) &#123; System.out.println(i); if (i % 2 == 0) &#123; try &#123; this.notifyAll(); this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if(i == 52)&#123; this.notifyAll(); &#125; &#125; &#125; public synchronized void printChar() &#123; for (char c = 'A'; c &lt;= 'Z'; c++) &#123; System.out.println(c); try &#123; this.notifyAll(); this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Collections使用","slug":"Collections使用","date":"2018-03-18T11:28:09.846Z","updated":"2018-03-19T10:20:50.522Z","comments":true,"path":"2018/03/18/Collections使用/","link":"","permalink":"http://yoursite.com/2018/03/18/Collections使用/","excerpt":"","text":"#码农 util.Collection与java.util.Collections区别 util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * xiaomu (dongnengyu@gmail.com) * 2018/3/18 */import java.util.Arrays;import java.util.Collections;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; intList = Arrays.asList(33, 24, 18, 6, 9, 99); //查找最小值 System.out.println(Collections.min(intList)); // 查找最大值 System.out.println(Collections.max(intList)); //使集合乱序 Collections.shuffle(intList); System.out.println(intList); //该方法用于返回一个不可变列表组成的n个拷贝的指定对象。 // 生成一个由10个100组成的整数列表 List&lt;Integer&gt; nCopiesList = Collections.nCopies(10, 100); //[100, 100, 100, 100, 100, 100, 100, 100, 100, 100] System.out.println(nCopiesList); //对集合排序，从小到大 Collections.sort(intList); System.out.println(intList); //对集合排序，从大到小，需要重写，以后再填坑 Collections.sort(intList); System.out.println(intList); //binarySearch System.out.println(Collections.binarySearch(intList, 18)); //copy //用两个参数，一个目标 List 和一个源 List, 将源的元素拷贝到目标，并覆盖它的内容。目标 List至少与源一样长。 List&lt;String&gt; listOne = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); List&lt;String&gt; listTwo = Arrays.asList(\"X\", \"Y\", \"Z\"); //listOne 是目标List,所以他的元素会被listTwo（源List）覆盖 Collections.copy(listOne, listTwo); System.out.println(listOne);// [X, Y, Z, D] System.out.println(listTwo);//[X, Y, Z] //disJoint //用于检查两个集合有无相同的元素，如果没有则返回true。 List&lt;String&gt; list3 = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); List&lt;String&gt; list4 = Arrays.asList(\"A\", \"Y\", \"Z\"); boolean disJoint = Collections.disjoint(list3, list4); // 返回false，因为两个集合都有A System.out.println(disJoint); //未完待续 &#125;&#125;","categories":[],"tags":[]},{"title":"java多线程","slug":"java多线程","date":"2018-03-17T02:26:36.847Z","updated":"2018-03-19T10:20:39.224Z","comments":true,"path":"2018/03/17/java多线程/","link":"","permalink":"http://yoursite.com/2018/03/17/java多线程/","excerpt":"","text":"#码农 创建一个线程 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过实现 Runnable 接口来创建线程创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：public void run()你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。Thread 定义了几个构造方法，下面的这个是我们经常使用的：Thread(Runnable threadOb,String threadName);这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。新线程创建之后，你调用它的 start() 方法它才会运行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class RunnableDemo implements Runnable &#123; private Thread t; private String threadName; RunnableDemo( String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName ); &#125; public void run() &#123; System.out.println(\"Running \" + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(\"Thread \" + threadName + \" interrupted.\"); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; public void start () &#123; System.out.println(\"Starting \" + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; RunnableDemo R1 = new RunnableDemo( \"Thread-1\"); R1.start(); RunnableDemo R2 = new RunnableDemo( \"Thread-2\"); R2.start(); &#125; &#125;编译以上程序运行结果如下：Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 通过继承Thread来创建线程123456789101112131415161718192021222324252627282930313233343536373839404142\u0003class ThreadDemo extends Thread &#123; private Thread t; private String threadName; ThreadDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;); T1.start(); ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;); T2.start(); &#125; &#125;","categories":[],"tags":[]},{"title":"blog小工具","slug":"blog小工具","date":"2018-03-16T05:03:46.806Z","updated":"2018-03-16T05:05:00.607Z","comments":true,"path":"2018/03/16/blog小工具/","link":"","permalink":"http://yoursite.com/2018/03/16/blog小工具/","excerpt":"","text":"#码农图片转base64","categories":[],"tags":[]},{"title":"ajaxForm 使用","slug":"ajaxForm","date":"2018-03-16T03:41:49.207Z","updated":"2018-03-16T03:53:33.160Z","comments":true,"path":"2018/03/16/ajaxForm/","link":"","permalink":"http://yoursite.com/2018/03/16/ajaxForm/","excerpt":"","text":"#码农 面临问题：form表单submit之后，后端会返回提示信息。但原生html无法获取后端返回的数据，就造成了这样一种局面：提交之后，页面发生跳转，在一个空白页面上显示了后端返回的json数据，用户体验0分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jQuery Form插件例子-ajaxForm()&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.form.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function () &#123; $(&apos;#myForm&apos;).ajaxForm(function () &#123; var json = &#123;&#125;; json.account = document.getElementById(&quot;account&quot;).value; json.password = document.getElementById(&quot;password&quot;).value; $.ajax(&#123; async: false, url: &quot;/login&quot;, data: JSON.stringify(json), method: &quot;post&quot;, contentType: &apos;application/json;charset=UTF-8&apos;, //返回数据 dataType: &quot;json&quot;, success: function (data) &#123; // alert(JSON.stringify(data)); var data2 = eval(data); var data3 = JSON.stringify(data); // alert(data2.login); if (data2.login == &quot;登录成功&quot;) &#123; $(&apos;#output1&apos;).html(&quot;登录成功&quot;).show(); &#125; else if (data2.login == &quot;账号不存在&quot;)&#123; $(&apos;#output1&apos;).html(&quot;账号不存在&quot;).show(); &#125; else &#123; $(&apos;#output1&apos;).html(&quot;密码错误&quot;).show(); &#125; &#125;, error: function (data) &#123; //失败的话 alert(&quot;fail&quot;); &#125;, &#125;); &#125; ) &#125; ) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt; Demo 1 : form插件的使用--ajaxForm(). &lt;/h3&gt;&lt;form id=&quot;myForm&quot; method=&quot;get&quot;&gt; 账号&lt;input type=&quot;text&quot; id=&quot;account&quot; value=&quot;&quot;&gt; &lt;/br&gt; 密码&lt;input type=&quot;password&quot; id=&quot;password&quot; value=&quot;&quot;&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; id=&quot;test&quot; value=&quot;提交&quot;/&gt; &lt;br/&gt; &lt;div id=&quot;output1&quot; style=&quot;display:none;&quot;&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"数据库错误：Parameter index out of range (1 > number of parameters, which is 0).","slug":"数据库错误：Parameter index out of range (1 > number of parameters, which is 0)","date":"2018-02-27T13:49:11.000Z","updated":"2018-02-27T13:52:03.523Z","comments":true,"path":"2018/02/27/数据库错误：Parameter index out of range (1 > number of parameters, which is 0)/","link":"","permalink":"http://yoursite.com/2018/02/27/数据库错误：Parameter index out of range (1 > number of parameters, which is 0)/","excerpt":"","text":"错误发生原因其实很简单😏，就是当设置参数时，没有相应的问号与之匹配（或者根本就没有？号）.如果是：Parameter index out of range (26 &gt; number of parameters, which is 25).翻译为：找到了25个问号，却插入了26个值，导致参数越界（根据得到的信息打印将很容易判断数据是否与数据库字段匹配等小问题）。 与sql语句有关的原因如下：1.？号被单引号包围。（如setString(1,”slkdjfkd”);时sql语句为：insert into table1 (c1,c2) values (‘?’,’?’)）。此时？会被作为参数传入，而不会再传入 setString里面的值。 2.sql语句中没有？号，在后面用到了set语句。（如：select * from table）；此时无需传值。传值就会出错。 3.初学者很常见的错误：?—？这两个问号是不同了，因为一个是中文，一个是英文，如果在sql语句中写入的是英文，将无法识别。 其他原因：1.连接已经关闭。 如果与其他操作语句一起公用conn时，如果上一操作已经关闭连接，则会报错。表现为：时而能够进行操作，时而不能。2.pstm没有初始化，无驱动包，得到连接出错等基础问题……","categories":[],"tags":[]},{"title":"Java字符串拼接","slug":"Java字符串拼接","date":"2018-02-26T11:37:05.000Z","updated":"2018-02-26T11:42:10.929Z","comments":true,"path":"2018/02/26/Java字符串拼接/","link":"","permalink":"http://yoursite.com/2018/02/26/Java字符串拼接/","excerpt":"","text":"plus方式 当左右两个量其中有一个为String类型时，用plus方式可将两个量转成字符串并拼接。 String a=&quot;&quot;;int b=0xb;String c=a+b; concat方式 当两个量都为String类型且值不为null时，可以用concat方式。 String a=&quot;a&quot;;String b=&quot;b&quot;;String c= a.concat(b); 理论上，此时拼接效率应该最高，因为已经假定两个量都为字符串，做底层优化不需要额外判断或转换，而其他方式无论如何优化，都要先走到这一步。 append方式 当需要拼接至少三个量的时候，可以考虑使用StringBuffer#append()以避免临时字符串的产生 StringBuffer buf=new StringBuffer()buf.append(&quot;a&quot;);if(someCondition){buf.append(&quot;b&quot;);}buf.append(&quot;c&quot;);String d=buf.toString(); 当a,b,c拼接起来会很长时，可以给在构造器中传入一个合适的预估容量以减少因扩展缓冲空间而带来的性能开销。 StringBuffer buf=new StringBuffer(a.length()+b.length()+c.length()); JDK对外提供的一些涉及可append CharSequence的参数或返回值类型往往是StringBuffer类型，毕竟安全第一，而StringBuffer大多数情况(包括append操作)线程安全。 若不会出现多线程同时对一实例并发进行append操作，建议使用非线程安全的StringBuilder以获得更好性能 其他 若需拼接至少三个量，只用一个连续拼接的语句就可完成时，从使代码简洁角度考虑，用plus方式。 String a=&quot;a&quot;;String b=&quot;b&quot;;String c=&quot;c&quot;;String d=a+b+c; 此时，第4句经JDK编译后其字节码(或)会自动优化为等效于下列代码编译后的字节码。 String d=new StringBuilder().append(a).append(b).append(c).toString(); 若采用模板+参数来替换占位符的方式或需同时对要拼接日期/数字进行格式化，可以用String.format()来实现 String c=String.format(&quot;a %s!&quot;,&quot;b&quot;); 此方式资源占用/耗时相对会稍多，毕竟首先要解析模板。当用方法封装并进行format条件调用时，整体效率也不算差。","categories":[],"tags":[]},{"title":"MarkDown文档插入图片","slug":"MarkDown文档插入图片","date":"2018-02-24T08:06:51.534Z","updated":"2018-02-24T08:40:52.176Z","comments":true,"path":"2018/02/24/MarkDown文档插入图片/","link":"","permalink":"http://yoursite.com/2018/02/24/MarkDown文档插入图片/","excerpt":"","text":"将图片嵌入Markdown文档中一直是一个比较麻烦的事情。通常的做法是将图片存入本地某个路径或者网络存储空间，使用URL链接的形式插入图片： ![image][url_to_image] 这样做一个明显的麻烦之处在于处理图片与Markdown文档的一致性上。如果我们要拷贝文档，或者图片遭到误删/云端链接失效，就会变得不便。最让我们省心的方法便是将图片直接放到文档内部。 一个将图片嵌入文档中的方法是使用base64编码。步骤比较简单： 将图片或截图保存在本地； 使用在线工具将图片转码至base64编码；(link1, link2)； 在文档中插入编码： 1![image][data:image/png;base64, ......] 当然base64编码一般很长，直接将编码放入段落内部会影响正常编辑。通常的做法是将base64编码定义到一个中间变量中，将编码本体放到文档末： 1234![image][tmp]your document here ...[tmp]:data:image/png;base64, ...... 使用该技巧的时候需要注意，并不是所有的Markdown编辑器都支持这种方法。而且一些Markdown编辑器只支持特定的图片格式。如有道云笔记只支持png格式的图片编码。需要在保存图片文件的时候加以注意。","categories":[],"tags":[]},{"title":"base64测试","slug":"base64测试","date":"2018-02-24T07:29:02.992Z","updated":"2018-02-24T07:58:43.330Z","comments":true,"path":"2018/02/24/base64测试/","link":"","permalink":"http://yoursite.com/2018/02/24/base64测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"舌尖上的中国3影评","slug":"舌尖上的中国3影评","date":"2018-02-24T06:57:07.579Z","updated":"2018-02-24T07:49:05.555Z","comments":true,"path":"2018/02/24/舌尖上的中国3影评/","link":"","permalink":"http://yoursite.com/2018/02/24/舌尖上的中国3影评/","excerpt":"","text":"把糟粕当做文化。把落后当做质朴。把迷信当做传统。把反智当做精华。几年前舌尖第一部横空出世，看完我会觉得“中国好吃的可真多”。再后来出了舌尖二，让我觉得“没用的废话可真多”。这部舌尖三看完几集，顿时觉得“中国落后的地方可真多”。全篇都是在宣扬愚昧和落后的生产方式，加之玄之又玄的忽悠，仿佛有一种传销的即视感。就好像某“导师”在台上给学员们介绍手中产品：“我这个锅，底是圆的，铲子是方的，体现了天圆地方的道家真理！前后两个把手，象征稳抓经济两手都要硬！滴两滴油，放一瓣蒜，象征2学1做的方针！我这个锅每个铁分子（经大家提醒应该是铁原子，化学知识都还给老师了……）都饱含大自然的气息，并且与宇宙引力波形成共振，吸收日月精华！用这口锅炒菜，不仅补铁补气补查克拉，背着锅出去旅行还能延年益寿！”大大前年笑话完台湾用爱发电，大前年我们笑话完朴槿惠信邪教，前年笑话完雷雷太极大师，去年笑话完日本的大忽悠煮饭仙人，今年我们又紧紧跟随反智的脚步，果然是【自古出神棍，东亚尤其多】 作者：湿身人面酱链接：https://www.zhihu.com/question/63393032/answer/324965613来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 有一个令人警惕的地方，节目里宣称西安回坊自唐朝就开始形成了。可实际上那时候根本没有什么回民。在舌尖上的中国这种美食类节目里，这个说法也许只是一个小错误。但是联系现在国内蔓延开来的泛清真化，更兼清真盐清真牛奶等等早已悄无声息地改变了很多人的生活，宗教势力抬头已无法遏制。傅统先《中国回教史》、金吉堂《中国回教史研究》、马以愚《中国回教史鉴》、邱树森《中国回族史》这些穆斯林已经开始明目张胆地篡改历史，如将一系列出身汉族的历史人物如朱元璋海瑞，划归于回族，如将回族马步芳等人一一洗白。一场有预谋的布局早就开始了。2018年央视狗年春晚，公然将尚存争议的涉及穆斯林地图宣布为丝路山水图，更是罔顾事实，直接指鹿为马喊出终点为伊斯兰圣地麦加。莫非不知正是伊斯兰毁灭了途径丝绸之路的那些中亚小国？（24日更新，此画原名涉疑，内容也涉疑，改之）文化渗透恐怖至斯！那么，这个又一次在央视播出的，堂而皇之地将回民历史往前推了一千年的说法，日后真的只是一个小错误么？ 作者：晏公子链接：https://www.zhihu.com/question/63393032/answer/323960751来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 #blog","categories":[],"tags":[]},{"title":"2017年总结","slug":"2017年总结","date":"2018-02-09T12:52:05.572Z","updated":"2018-02-18T15:15:25.182Z","comments":true,"path":"2018/02/09/2017年总结/","link":"","permalink":"http://yoursite.com/2018/02/09/2017年总结/","excerpt":"","text":"Linux服务器篇- [x] 租服务器（vps） - [x] 了解vps运作原理（XEN、OpenVZ、KVM、Hyper-V、HVM等） - [x] ssh终端命令操作、如文件管理、vim工具 - [x] 熟悉VIM - [x] 在终端中使用包管理工具安装并配置软件 - [x] 在终端中编译软件源代码方式安装并配置 - [x] 学会部署调试Tomcat、MySQL、Apache等服务器必备软件 - [x] 在vps上使用已有的框架（wordpress、typecho、GitHubPage）搭建博客 - [x] 使用Tomcat、httpd分别部署项目（完全使用自己的前端加后端代码实现简陋的blog）并能尝试解决各种秘制bug - [x] 部署搭建卖翻墙服务的网站、但由于政策原因并不敢开放注册售卖账号（关门大吉） linux深入学习篇（深坑）- [x] linux内核编译（《操作系统原理》） - [x] shell - [ ] 深坑2018继续中。。。。。。 openwrt路由器操作系统深入学习（荒废学业、已弃坑）- [x] 在家用路由器中通过硬改方式刷入openwrt操作系统 - [x] 能编译自己写的代码（hello world）到路由器上运行 - [x] 部署Mysql、python、Apache等常用软件到路由器中并将其改造成一个玩具（无聊） - [x] 网络负载均衡调试 基础学习篇Python- [ ] 大一学的，妈蛋几乎忘了😭 java web- [x] javaSE - [x] HTML - [x] CSS和JavaScript的初步认识 - [x] XML语法和应用 - [x] bootstrap框架学习中 - [x] servlet - [x] jsp - [x] MySQL - [ ] MySQL的JDBC（尚待学习） - [x] Tomcat初步学习 软件工程- [x] 好像没啥好总结的😹 展望未来篇- [ ] 三大框架熟练运用 - [ ] 算法深坑 - [ ] 数据结构重新学习 - [ ] 复习python.爬虫学习 - [ ] 暂时想不到啥了，想到再补✍️","categories":[],"tags":[]},{"title":"sourcing与purchasing的区别","slug":"sourcing与purchasing的区别","date":"2017-12-02T17:32:17.000Z","updated":"2018-03-06T02:07:19.561Z","comments":true,"path":"2017/12/03/sourcing与purchasing的区别/","link":"","permalink":"http://yoursite.com/2017/12/03/sourcing与purchasing的区别/","excerpt":"","text":"#供应链 导读：相对而言，Sourcing的过程可能很短，也可能很长，但确是“一次性行为”，一旦选定合适的供应商并把他们带上正规，Sourcing的任务就基本完成。当然Sourcing的过程可能很长。然后是Purchasing去执行日常订单管理。当然如果Sourcing选定的供应商有表现问题，例如质量、交货、价格等，那么Sourcing有可能再度涉入，寻找新的供应商。当然这种区分有点理论化。在很多公司，Sourcing和Purchasing是由同一组人员完成。但对于建制完全的大公司，总体趋势是把Sourcing从Purchasing分离出来。 定义上的区别与采购有关的词有：Buyer，Purchasing，Procurement和Sourcing。我把它们分别译为：买；采购；获取（或资源获取）；寻源与货源组织。从他们出现的顺序上也可以看出它们虽然最终都完成了采购的业务，但含义和执行工程是不同的： 1．Buyer只是简单的买，完成了“买”的动作和买入了某样物资或服务，侧重于下单，并跟踪订单； 2．Purchasing则有采购的意思，即先要采，然后再买进； 3．Procurement是实现了资源获取，有整合与更好的获得资源的意思； 4．Sourcing一般是制造型企业用的，要求有很强的理工知识和商业感觉，是要去在全球范围内找到最好的资源、然后将找到的货源和资源组合在一起来更好地加以利用，侧重于物料和供应商的开发，开发完成后交给buyer下单跟踪。它们的演变是随着采购业务不断发展的需求而出现和扩展而来的。 职能上的区别和具体分工 Sourcing与Purchasing 翻译成中文， Sourcing，Purchasing和buyer都是采购的意思，但实际上他们的职能是大不相同。 Sourcing是根据客户的需求，寻找，发现，评估，审核，发展合格的供应商，有的叫procurement，意思是发现采购。一般对应中文是供应商开发或发展多。同时也包括新BOM（Bill of Material）报价和谈价的工作。侧重于技术层面，是去寻找和确定符合资质的新供应商或新产品的供应商。偏重于对整体项目的分析。比如你需要采购产品A，你要对A 进行风险分析，比如这个项目是否适合中国的市场，他的技术参数是否是大部分供应商能达到；近期的原油价格会不会涨价，造成运费增加，或者塑料涨价格，你做这个项目有多少saving ；如果有些状况你开始就预料到的并不利于这样项目，你有权将项目停掉，以免浪费人力物力，Sourcing 的这个工作和职位,对潜在风险的预测是有比较高的要求，同时他还可能负责初期的供应商寻找和筛选。 Purchasing是根据sourcing的合格供应商名录，结合生产和销售需求，在合适的时间采购合适的数量的产品。对应中文叫采购的多。是sourcing engineer分析了整个项目风险后决定开始做这个项目后，Purchaser 是项目的执行者，就是去像供应商进行谈价格比价格，确定具体供应商，跟单确认交货期，和工厂协调，邮寄样品，Purchaser 是事物的具体执行者， 你拿到的这些Potential suppliers list 时，供应商的情况要及时和Sourcing engineer 交流。他比较权威，基本上凭借他的经验是一眼可以看出在这个行业中哪些供应商很有能力，哪些不太好。所以说，Sourcing 是比较高级的，他把握了一个项目的整体方向；Purchase 是在正确方向的情况下做一个项目的实施者，主要执行具体的日常采购任务。相对于Sourcing，Purchasing更侧重于订单处理（PO Transaction），即询价、下订单、跟踪订单、催单、收货、付款等。现在因为大量的使用ERP等IT资源，许多大公司的从事 Purchasing的buyer同时也是Planner，即计划人员同时也是采购人员，他们会根据系统的相应信息来发行订单。有一些日资企业因为分工相当细，Planner不会发行订单与供应商联系，还是由BUYER在做订单工作。 相对而言，Sourcing的过程可能很短，也可能很长，但确是“一次性行为”，一旦选定合适的供应商并把他们带上正规，Sourcing的任务就基本完成。当然Sourcing的过程可能很长。然后是Purchasing去执行日常订单管理。当然如果Sourcing选定的供应商有表现问题，例如质量、交货、价格等，那么Sourcing有可能再度涉入，寻找新的供应商。当然这种区分有点理论化。在很多公司，Sourcing和Purchasing是由同一组人员完成。但对于建制完全的大公司，总体趋势是把Sourcing从Purchasing分离出来。 从上面的分工不难看出，Sourcing相对更战略一些，有可持续性，需长期规划；而Purchasing更侧重于日常工作。可以是单独一次商务购买行为。在实际工作中，Sourcing与产品部、工程技术人员等交流较多，而Purchasing则主要是支持生产部、客户服务部（例如备件、配件）。Sourcing team一般由Sourcing Manager加采购/供应商工程师构成；而Purchasing则由Purchasing Manager加采购员、催货员、检验员等组成。 就现阶段的大趋势来看，采购部门的职能逐渐从Purchasing向Sourcing过渡，就是采购的作用和在公司的地位不断提升的过程。采购部门也从原来的订单处理更多参与到战略决策过程，例如决定公司自己制造还是采购（Make or Buy）、选择合适的战略性合作供应商、很大程度上决定产品的最终价格（因为采购部分占的分量越来越大）。当然，对个人而言，如果想向Sourcing方面发展的话，Purchasing的功底还是很有好处。因为那些日常工作也挺能锻炼人的基本功。 采购工作最核心的权力有三个：supplier selection（供应商样品认证）, allocation（采购量分配）和cost down（成本降低）。看一个采购的重要性和工作含金量，我们就看他可以控制住三个权力中的哪些部分。Sourcing肯定可以掌握supplier selection，负责供应商出样，完成样品认证，在系统中建立合格供应商的代码。 Buyer 就是买手、代理之类的，一般更贴近Purchasing，但服装业，或奢侈品行业的sourcing叫buyer或merchandiser的多，但对应中文是买手，而不单是采购。 Sourcing工作职责： (1)供应商开发(或者参与产品开发，具备专业能力） (2)核定采购订单分配比率 (3)主导新供货商的评鉴 (4)主导合格供货商绩效评估与管理 (5)竞标、议价、合约签订与管理 (6)采购单价/标准单价建立与维护厂商报价单(包括单价、材料Lead Time、最小订购量、单位包装)之制订与发行单价记录单(Cost Pattern)之发行与归档 (7)采购单价及付款条件变动时之系统及时维护 (8)异常付款确认与会签 (9)协助工厂必要之材料(或材损)状况处理 (10)总公司采购开发员协助开立L/C作业 (11)e-Supply 导入之前期作业, 并依循供货商管理办法 Buyer工作职责: (1)P/R作业：材料请购书制作 (2)P/O作业：采购订单制作、发行、归档 (3)材料交期确认、控制与跟催 (4)参与新供货商评鉴及合格供货商绩效评估及回馈供货商日常现。 (5)材料入库、退库处理 (6)MDR跟踪与归档。 (7)月结对帐、Invoice传递及付款申请单 8)材损过高时之供货商扣款 (9)执行与导入e-Supply, 并依循供货商管理办法 不同行业的不同定位 在大多数体制不完全的公司里，Sourcing和Purchasing是由同一组人员完成。但对于建制完全的大公司，或者是将Sourcing从Purchasing分离出来、成为两个独立的部门，或者是并在一起、成为Commodity经理的统筹管理范围。一般这两个职能不会并在同一部门。如果是规模很大的公司或一个公司很高层的级别上。应该并在一起,成为Commodity经理的统筹管理范围。但如果是不太大的公司或级别不高的地方，一般也没有Commodity经理，Sourcing会被放到技术部门去。 不同公司，对这些职位的定义可能不同。有的公司Commodity Manager可能负责的是一类产品的采购战略，例如大的供应商选择方向，签订合同，供应商总体绩效等。Purchasing Manager负责日常订单有关的任务，管理Buyer或Procurement Agent。还有一个Materials Manager，该职位的职责从字眼上看更广泛，负责与材料有关的所有任务，例如规划（要买多少，什么时候买）、采购（围绕订单）、库存管理、仓储、物流等。 公司小了，Commodity Manager、Purchasing Manager、Materials Manager很可能就是一个人。在有些公司、行业，这些职位之间的界限有时挺模糊。有些公司，sourcing不能掌握allocation（采购量分配）和cost down（成本降低），这个时候，sourcing的地位就非常尴尬，工作很不好展开，最后很容易变成他们就是到处求人打样，而供应商爱理不理，因为打样要耗费供应商成本，但是后来有不有订单下来，成交价格是多少，sourcing又不能控制，这时，做purchasing的buyer就非常关键，实际作用就大于sourcing。 如果三个权力都集中在sourcing那里，buyer就等于被架空、无事可做，sourcing工作的好坏将会很大程度上影响采购部门的绩效。可是，很多公司并没有把这三项权力集中到采购部，而是被公司更高层的领导所控制。这时，采购部的重要性就大大削弱，甚至退居次席，在选择供应商和谈价格时，都是走过场，停留在表面。至于企业是否以最好的价格买到物料，采购部根本就回答不了。我看过一些大公司的采购记录，他们虽然采用最先进的系统和管理手段，但是他们的采购价格并不好，有些时候非常糟糕，原因就是采购和供应管理中，形式大于实质，采购部没有被赋予足够的权力，没有得到足够的支持，开展工作中有太多的掣肘。 purchasing每个公司可能不一样。sourcing的关键是你是否有决定使用哪个供应商的权利。有些公司的架构是这样： 1.regional purchasing manager-他们制定相应产品的regional strategy, 决定使用那些供应商 2.plant purchasing manager-他们协调SCM（Supply Chain Management）和regional purchasing manager 的关系，同时负责小料的采购 regional purchasing manager的职责： Spending analysis Regular price negotiation Regional strategy setup Saving project initiate Price development control Coordinate global-regional strategy 所以说实权在regional purchasing，实际上就是我们说的sourcing。最基本的一条规则是：谈价格、决定供应商的人绝对不能下单，下单的人绝对不能谈价格。避免道德风险。","categories":[],"tags":[]}]}